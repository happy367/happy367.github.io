<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vite</title>
      <link href="/2023/03/31/vite/"/>
      <url>/2023/03/31/vite/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2023/03/31/webpack/"/>
      <url>/2023/03/31/webpack/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react</title>
      <link href="/2023/03/31/react/"/>
      <url>/2023/03/31/react/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/03/31/git/"/>
      <url>/2023/03/31/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h2><p>1、初始化项目，初始化git仓库，做一次提交操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init # 当前项目初始化为git仓库</span><br><span class="line">git add . # 当前目录所有文件上传到暂存区域</span><br><span class="line">git commit -m ‘init project’ # 将暂存区域文件上传到本地仓库</span><br></pre></td></tr></table></figure><p>2、创建分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名字 # 创建制定名称的分支</span><br><span class="line">git branch dev</span><br></pre></td></tr></table></figure><p>3、查看分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch # 查看所有分支，* 表示当前工作分支</span><br><span class="line">git branch -v # 查看分支详情，包括了分支指向commitId以及提交信息</span><br></pre></td></tr></table></figure><p>4、切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名字 # 切换到指定分支</span><br><span class="line">git checkout -b 分支名字 # 创建并且切换分支</span><br></pre></td></tr></table></figure><p>5、删除分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名字 # 删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录)</span><br><span class="line">git branch -D 分支名字 # 强制删除一个分支，该分支有没有合并到当前分支的提交记录</span><br></pre></td></tr></table></figure><p>6、重命名分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -m 分支名 新的分支名</span><br><span class="line">例子说明：</span><br><span class="line">git branch -m dev Dev1</span><br><span class="line">git branch -v # 查看所有分支详情</span><br></pre></td></tr></table></figure><h2 id="版本回退指令"><a href="#版本回退指令" class="headerlink" title="版本回退指令"></a>版本回退指令</h2><ul><li>回退版本：<br>git reset –hard HEAD^ //回退到上一个版本，HEAD指当前版本 ‘^’上一个<br>git reset –hard commit_id //回退到指定commit id版本，可通过git log查看提交日志<br>git revert commit_id //前进一个版本此版本的内容为指定的commit_id版本的内容</li><li>配合使用：<br>git log –pretty=online //查看提交日志，从而查到commit_id<br>git reflog //查看命令历史</li><li>git revert与git reset的区别</li></ul><p>如果已经有A -&gt; B -&gt; C，想回到B：<br><strong>方法一</strong>：reset到B，丢失C：<br>相当于变成A -&gt; B</p><p><strong>方法二：</strong>再提交一个revert反向修改，变成B：<br>相当于变成A -&gt; B -&gt; C -&gt; B<br>C还在，但是两个B是重复的</p><p>看你的需求，也许C就是瞎提交错了（比如把密码提交上去了），必须reset<br>如果C就是修改，现在又要改回来，将来可能再改成C，那你就revert</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/2023/03/31/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2023/03/31/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络传输</title>
      <link href="/2023/03/31/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
      <url>/2023/03/31/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端安全</title>
      <link href="/2023/03/31/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
      <url>/2023/03/31/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 前端安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><h3 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h3><p>超文本传输协议：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p><h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><img src="https://zyhxwing.gitee.io/images/http/1347_1.png" alt="HTTP常见状态码" style="zoom:50%;"><p><strong>HTTP常见状态码</strong></p><ul><li>1xx 提示信息，表示目前是协议处理的中间状态</li><li>2xx 成功，报文已经被收到并且被正确处理<ul><li>200 表示一切正常</li><li>204 功能与200基本相同，但是本身响应头没有数据</li><li>206 表示响应的资源是其中的一部分，一般应用于HTTP分块下载</li></ul></li><li>3xx表示客户端请求的资源发生了变动<ul><li>301 表示永久重定向，说明请求的资源已经不存在，需要改用新的url来访问</li><li>302 表示临时重定向，说明请求的资源还在，但是需要用另一个url来访问<br>301、302会在响应头用location，指明后续要跳转的url</li><li>304 协商缓存</li></ul></li><li>4xx表示客户端发送的报文有误，服务器无法处理，表示错误<ul><li>400 表示出现错误</li><li>403 服务器禁止访问</li><li>404 客户端请求的资源服务器没有找到</li></ul></li><li>5xx表示客户端请求报文正确，但服务器处理错误<ul><li>500 表示出现错误</li><li>501 服务器不支持该功能</li><li>502 服务器网关错误</li><li>503 服务器繁忙，暂无法响应</li></ul></li></ul><h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><p><strong>http 请求报文格式</strong>                      </p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331180243751.png" alt="image-20230331180243751"></p><p><strong>http 响应报文格式</strong></p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331180300079.png" alt="image-20230331180300079"></p><ul><li>host：表示服务器请求的域名</li><li>content-length: 表示服务器在返回数据的时候，本次返回的数据长度</li><li>connection：keep-alive 表示客户端要求服务器使用tcp持久连接</li><li>content-type：服务器回应时告诉客户端本次数据是什么格式 一般取值为utf-8</li><li>content-encoding：表示返回的数据用了哪种压缩方法</li></ul><h3 id="get与post请求区别"><a href="#get与post请求区别" class="headerlink" title="get与post请求区别"></a>get与post请求区别</h3><ul><li><p>get请求一般用来请求获取数据</p><p>post请求一般作为发送数据到后台，传递数据，创建数据</p></li><li><p>get请求也可以传参到后台，但是传递的参数则显示在地址栏，安全性低，且参数的长度也有限制（2048字符）</p><p>post请求则是将传递的参数放在request body中，不会在地址栏显示，安全性比get请求高，参数没有长度限制</p></li><li><p>get请求刷新浏览器或者回退没有影响</p><p>post请求则会重新请求一遍</p></li><li><p>get请求可以被缓存，也会保留在浏览器的历史记录中</p><p>post请求不会被缓存，也不好保留在浏览器的历史记录中</p></li><li><p>get请求通常是通过url地址请求</p><p>post常见的则是form表单请求</p></li></ul><h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p><ul><li>GET : 请求指定的页面信息，并返回实体主体。</li><li>POST : 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>HEAD : 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li></ul><p>HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><ul><li>OPTIONS : 允许客户端查看服务器的性能。</li><li>PUT : 从客户端向服务器传送的数据取代指定的文档的内容。</li><li>PATCH : 是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li><li>DELETE : 请求服务器删除指定的页面。</li><li>TRACE : 回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT : HTTP 1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><h3 id="浏览器中输入一个网址后，具体发生了什么"><a href="#浏览器中输入一个网址后，具体发生了什么" class="headerlink" title="浏览器中输入一个网址后，具体发生了什么"></a>浏览器中输入一个网址后，具体发生了什么</h3><ol><li>解析URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li><li>缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li><li>DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。<strong>本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，</strong>本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li><li>获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，<strong>本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址通过ARP协议来获取</strong>需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 <strong>ARP协议会先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</strong></li><li>TCP三次握手：<strong>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了</strong>。</li><li>HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。<strong>首先由客户端向服务器端发送使用的协议的版本号、一个随机数client random和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数server random和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数pre-master，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</strong></li><li>返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li><li>页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li><li>TCP四次挥手：<strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</strong></li></ol><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>200（from disk cache）<br>强缓存根据下面两个http响应头部来实现，表示资源在客户端缓存的有效期</p><ul><li>cache-control 相对时间，优先级更高</li><li>expires 绝对时间</li></ul><p>实现步骤：<br>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>304<br>协商缓存可以通过两种方式来实现</p><p>请求头部 if-modified-since，响应头部 last-modified</p><ul><li>响应头部 last-modified 该响应资源的最后修改时间</li><li>请求头部 if-modified-since 当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>请求头部 if-none-match，响应头部 etag</p><ul><li>响应头部 etag 唯一标识响应资源</li><li>请求头部 if-none-match 当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p>注意，协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p><h4 id="三种刷新操作对-http-缓存的影响"><a href="#三种刷新操作对-http-缓存的影响" class="headerlink" title="三种刷新操作对 http 缓存的影响"></a>三种刷新操作对 http 缓存的影响</h4><p>正常操作：地址栏输入 url，跳转链接，前进后退等。强制缓存有效，协商缓存有效<br>手动刷新：f5，点击刷新按钮，右键菜单刷新。强制缓存失效，协商缓存有效<br>强制刷新：ctrl + f5，shift+command+r。强制缓存失效，协商缓存失效。</p><h3 id="HTTP特性与演变"><a href="#HTTP特性与演变" class="headerlink" title="HTTP特性与演变"></a>HTTP特性与演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p><strong>优点</strong></p><ul><li>简单，header+body，头部内容为key-value</li><li>灵活、易于拓展</li><li>应用广泛</li></ul><p><strong>缺点</strong></p><ul><li>无状态，减少服务器负担的同时也需要进行额外的身份认证（cookie）</li><li>明文传输，不安全</li></ul><p><strong>特性</strong></p><ul><li>长连接，服务器和客户端可以长时间保持连接</li><li>管道网络传输，发送请求不用等响应就可以发送接下来的请求</li><li>队头堵塞，响应请求需要一步一步响应，如果队伍头部的响应很慢，接下来的响应就会堵塞</li></ul><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p><strong>特性</strong></p><ul><li><strong>头部压缩</strong>，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li><li><strong>二进制格式</strong>，增加了信息传输的效率</li><li><strong>数据流</strong>，对数据包做标记，指出它属于哪个回应。在 HTTP/2 中每个请求或响应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID），不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</li><li><strong>多路复用</strong>，在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li><li><strong>服务器推送</strong>，服务端不再是被动地响应，可以主动向客户端发送消息。</li></ul><p><strong>缺点</strong></p><ul><li>TCP队头堵塞问题。HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</li></ul><p><strong>简而言之就是某个TCP的packet也就是序列号丢失了，那么之后所有的TCP都需要等待重传机制返回丢失的包，才能继续运行，否则数据不连续是无法被读取到的</strong></p><h4 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h4><p><strong>优点</strong></p><ul><li><strong>无队头堵塞，基于UDP实现HTTP链接</strong>，通过QUIC协议实现可靠传输。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</li><li><strong>更快的连接速度</strong>，QUIC内部包含了TLS可以同时完成建立连接与密钥协商</li><li><strong>连接迁移</strong>。基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。<strong>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</strong>，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</li></ul><p><strong>缺点</strong></p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS改进内容之TLS协议"><a href="#HTTPS改进内容之TLS协议" class="headerlink" title="HTTPS改进内容之TLS协议"></a>HTTPS改进内容之TLS协议</h3><ul><li>信息加密： HTTP 交互信息是被加密的，第三方就无法被窃取；</li><li>校验机制：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li><li>身份证书：证明淘宝是真的淘宝网；</li></ul><h3 id="SSL-TLS握手详解"><a href="#SSL-TLS握手详解" class="headerlink" title="SSL/TLS握手详解"></a>SSL/TLS握手详解</h3><ul><li>TLS第一次握手<ul><li>客户端发送Client Hello消息，包含了版本号、支持的密码套件列表、随机数Client Random</li></ul></li><li>TLS第二次握手<ul><li>服务端收到Client Hello消息之后，首先会确认版本号是否支持，然后从密码套件列表中选择一个密码套件RSA，然后生成出一个随机数Server Random，最后返回Server Hello消息，包含了以上内容</li><li>服务端发送Server Certificate给客户端，这个消息里含有数字证书</li><li>服务端发送Server Hello Done给客户端，代表本次握手结束，已经把东西给了客户端</li></ul></li><li>TLS第三次握手<ul><li>证书认证机构CA签发证书流程<ul><li>CA把持有者的信息打包，进行hash计算，得到一个hash值、</li><li>CA会使用自己的私钥对hash值加密，生成签名 Certificate Signature</li><li>将签名添加到文件证书上，形成数字证书</li></ul></li><li>客户端验证数字证书流程<ul><li>客户端会使用相同的算法也生成一个hash值</li><li>客户端再收到数字证书后，根据操作系统提供的CA的公钥对证书解密，获得了CA传递的hash值</li><li>两个hash值对比，相同则为可以信赖的证书</li></ul></li><li>客户端验证证书完毕之后，会生成一个新的随机数pre-master，用服务器RSA公钥加密该随机数，通过Client Key Exchange消息传递给服务端</li><li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)</li><li>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</li><li>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是 <strong>对称密钥</strong>，用于对后续的 HTTP 请求/响应的数据加解密。</li><li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。</li><li>然后，客户端再发一个「Encrypted Handshake Message（Finishd） 」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li></ul></li><li>TLS第四次握手<ul><li>服务器发送Change Cipher Spec、Encrypted Handshake Message（Finishd） 消息，此时双方都验证加密和解密没问题，则握手完毕</li></ul></li></ul><p><strong>密钥交换算法：因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</strong></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p><ul><li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：源地址、源端口、目的地址、目的端口</p><h3 id="为何TCP可靠UDP不可靠"><a href="#为何TCP可靠UDP不可靠" class="headerlink" title="为何TCP可靠UDP不可靠"></a>为何TCP可靠UDP不可靠</h3><ul><li>TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。对于每份报文也存在校验，保证每份报文可靠性。</li><li>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。仅仅在IP数据报头部加入校验和复用。UDP没有服务器和客户端的概念。UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</li></ul><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ol><li><strong>连接</strong> : 连接TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。</li><li><strong>服务对象、连接数</strong> : 服务对象TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</li><li><strong>可靠性</strong> : 可靠性TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。</li><li><strong>流量控制</strong> : 拥塞控制、流量控制TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li><strong>首部开销</strong> : 首部开销TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li><li><strong>传输方式</strong> : 传输方式TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li><li><strong>分片传播</strong> : 分片不同TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li><li><strong>应用</strong> : 由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：FTP 文件传输；HTTP / HTTPS；由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS 、SNMP 等；视频、音频等多媒体通信；广播通信。</li></ol><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331162250850.png" alt="image-20230331162250850"></p><ul><li>一开始，客户端和服务端都处于<strong>close</strong> 状态。先是服务端主动监听某个端口，处于 <strong>listen</strong> 状态</li><li>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把<strong>SYN 标志位置为 1</strong> ，表示 SYN 报文。接着<strong>把第一个 SYN 报文发送给服务端</strong>，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <strong>SYN-SENT</strong> 状态。</li><li>服务端在收到客户端的SYN请求之后，会初始化自己的序号，将此序号填入TCP首部的序号字段中，其次把TCP首部的确认应答号字段填入client_isn + 1，接着把 <strong>SYN 和 ACK 标志位置为1</strong> 。把该报文发给客户端，该报文也不包含应用层数据，之后服务器处于 <strong>SYN-RCVD</strong> 状态。</li><li>客户端在收到服务端报文后，还要再向服务端回应最后一个应答报文，首先将该报文的<strong>ACK置为1</strong>，其次确认应答号填入server_isn+1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，指挥客户端处于<strong>established</strong>状态。</li><li>服务端在收到客户端的应答报文之后，也进入<strong>established</strong>状态。</li></ul><h4 id="为什么不是四次握手、两次握手"><a href="#为什么不是四次握手、两次握手" class="headerlink" title="为什么不是四次握手、两次握手"></a>为什么不是四次握手、两次握手</h4><p>1.<strong>三次握手才可以阻止重复历史连接的初始化（主要原因</strong>）</p><p><strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</strong></p><p>因此，要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p><p>2.<strong>三次握手才可以同步双方的初始序列号</strong></p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p><p><strong>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</strong></p><p>3.<strong>三次握手才可以避免资源浪费</strong></p><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p><p><strong>不使用「两次握手」和「四次握手」的原因：<br>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</strong></p><h4 id="三次握手每次报文丢失后果"><a href="#三次握手每次报文丢失后果" class="headerlink" title="三次握手每次报文丢失后果"></a>三次握手每次报文丢失后果</h4><p><strong>第一次握手丢失</strong></p><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<strong>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。如果在重传次数超过最大重传次数之后，服务端依旧没响应ACK，则会断开TCP连接</strong></p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331165823382.png" alt="image-20230331165823382"></p><p><strong>第二次握手丢失</strong></p><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。</p><p>第二次握手的 SYN-ACK 报文其实有两个目的 ：第二次握手里的 ACK， 是对第一次握手的确认报文；第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</p><p><strong>因此，当第二次握手丢失了，客户端和服务端都会重传：<br>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。</strong></p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170108102.png" alt="image-20230331170108102"></p><p><strong>第三次握手丢失</strong></p><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p><p><strong>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</strong></p><p>注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170209247.png" alt="image-20230331170209247"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="https://zyhxwing.gitee.io/images/http/1351_1.png" alt="四次挥手" style="zoom:50%;"><p><strong>四次挥手</strong></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 <strong>FIN 报文</strong>，之后客户端进入 <strong>FIN_WAIT_1</strong>状态。</li><li>服务端收到该报文后，就向客户端发送 <strong>ACK</strong> 应答报文，接着服务端进入 <strong>CLOSED_WAIT</strong> 状态。</li><li>客户端收到服务端的 ACK 应答报文后，之后进入 <strong>FIN_WAIT_2</strong>状态。</li><li>等待服务端处理完数据后，也向客户端发送<strong>FIN 报文</strong>，之后服务端进入 <strong>LAST_ACK</strong> 状态。</li><li>客户端收到服务端的 FIN 报文后，<strong>回一个 ACK应答报文</strong>，之后进入 <strong>TIME_WAIT</strong> 状态</li><li>服务器收到了 ACK 应答报文后，就进入了 <strong>CLOSED</strong> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 2MSL 一段时间后，自动进入 <strong>CLOSED</strong> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p><h4 id="为什么需要挥手四次"><a href="#为什么需要挥手四次" class="headerlink" title="为什么需要挥手四次"></a>为什么需要挥手四次</h4><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p><p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p><h4 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h4><p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p><h4 id="四次挥手丢失了会发生什么"><a href="#四次挥手丢失了会发生什么" class="headerlink" title="四次挥手丢失了会发生什么"></a>四次挥手丢失了会发生什么</h4><p><strong>第一次挥手丢失</strong></p><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，<strong>重传 FIN 报文</strong>，重发次数由 tcp_orphan_retries 参数控制。当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p><p><strong>第二次挥手丢失</strong></p><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。在前面我们也提了，<strong>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手 ，或者达到最大的重传次数。</p><p><strong>第三次挥手丢失</strong></p><p><strong>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文</strong>，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><p><strong>第四次挥手丢失</strong></p><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，<strong>服务端就会重发 FIN 报文</strong>，重发次数仍然由前面介绍过的</p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170307694.png" alt="image-20230331170307694">          <img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170326836.png" alt="image-20230331170326836"></p><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170507698.png" alt="image-20230331170507698" style="zoom:80%;"><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170525573.png" alt="image-20230331170525573" style="zoom:80%;"></p><h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><ol><li><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p></li><li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p></li><li><p>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></li><li><p>TCP 的接收端会丢弃重复的数据。</p></li><li><p>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p></li><li><p>拥塞控制： 当网络拥塞时，减少数据的发送。</p></li><li><p>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p></li><li><p>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p></li><li></li></ol><h2 id="OSI七层模型和TCP-IP四层模型"><a href="#OSI七层模型和TCP-IP四层模型" class="headerlink" title="OSI七层模型和TCP/IP四层模型"></a>OSI七层模型和TCP/IP四层模型</h2><p><img src="https://zyhxwing.gitee.io/images/http/1355_1.png" alt="OSI七层模型和TCP/IP四层模型"></p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li>应用层<br>网络服务与最终用户的一个接口。<br>协议有： HTTP（超文本传输协议） FTP（文本传输协议） TFTP（简单文本传输协议） SMTP（简单邮件传输协议） SNMP（简单网络管理协议） DNS（域名系统） TELNET（远程终端协议） HTTPS（超文本传输安全协议） POP3（邮件协议版本3） DHCP（动态主机配置协议）</li><li>表示层<br>数据的表示、安全、压缩。<br>格式有：JPEG、ASCll、EBCDIC、加密格式等</li><li>会话层<br>建立、管理、终止会话。<br>对应主机进程，指本地与远程主机正在进行的会话</li><li>传输层<br>定义传输数据的协议端口号，以及流控和差错校验<br>协议有：TCP、UD，数据包一旦离开网卡即进入网络传输层</li><li>网络层<br>进行逻辑地址寻址，实现不通网络之间的路径选择（路由选路）<br>协议有：ICMP、IGMP、IP（IPV4 IPV6）</li><li>数据链路层<br>建立逻辑连接、进行硬件寻址，差错校验等功能（有底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不纠正</li><li>物理层<br>建立、维护、断开物理连接（由底层网络定义协议）</li></ul><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><ul><li><p>应用层<br>应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.</p></li><li><p>传输层<br>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP).TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.</p></li><li><p>网络层<br>主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务</p></li><li><p>网络接口层<br>网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2023/03/31/css/"/>
      <url>/2023/03/31/css/</url>
      
        <content type="html"><![CDATA[<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p> 内容(content)、内边距/填充(padding)、外边距/边界(margin)、 边框(border)；</p><p><img src="/2023/03/31/css/image-20230331142759880.png" alt="盒模型"></p><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><ol><li>圆角border-radius</li><li>阴影之box-shadow</li><li>阴影之text-shadow</li><li>背景渐变linear-gradient</li><li>转换transform</li><li>translate()移动</li><li>rotate()旋转</li><li>scale()缩放</li><li>skew()倾斜</li><li>3D转换之rotateX()</li><li>3D转换之rotateY()</li><li>translate3d()</li></ol><ul><li>过渡transition</li></ul><ol><li>动画animation</li></ol><ul><li>@keyframes创建动画</li><li>animation执行动画</li></ul><ol><li>媒体查询 自动获取当前设备的屏幕信息. 以便于采用渲染方式. 使同一种样式在不同设备上显示出不同的效果。</li></ol><ul><li>设置meta标签</li><li>媒体查询语句</li></ul><ol><li>响应式布局 响应式局部就是让一套代码能够在不同设备上显示. 通过隐藏或者缩小相关元素来实现整个网页的功能完整性和美观性</li><li>栅格系统 col/row栅格系统是媒体查询的具体实现. 是一种规定的写法. 能够最小限度保证在各个设备上的显示美观性。</li></ol><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><p>css选择器优先级最高到最低顺序为：</p><ol><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div,h1,p)</li><li>子选择器(ul &lt; li)</li><li>后代选择器(li a)</li><li>伪类选择(a:hover,li:nth-child)</li></ol><p>当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，用到谁的值谁的优先级就高。<br>我们来看一下css选择器优先级的算法：</p><ul><li>每个规则对应一个初始”四位数”：0、0、0、0</li><li>若是 行内选择符，则加1、0、0、0</li><li>若是 ID选择符，则加0、1、0、0</li><li>若是 类选择符/伪类选择符，则分别加0、0、1、0</li><li>若是 元素选择符，则分别加0、0、0、1</li></ul><p>!important的优先级是最高的，但出现冲突时则需比较”四位数“;<br>优先级相同时，则采用就近原则，选择最后出现的样式;<br>继承得来的属性，其优先级最低。</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="元素知道宽高"><a href="#元素知道宽高" class="headerlink" title="元素知道宽高"></a>元素知道宽高</h3><ul><li>绝对定位、相对定位、calc计算偏移距离</li><li>绝对定位、相对定位、margin计算偏移距离</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">        //calc</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">        //<span class="attribute">margin</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="元素不知道宽高"><a href="#元素不知道宽高" class="headerlink" title="元素不知道宽高"></a>元素不知道宽高</h3><ul><li>绝对定位、相对定位、calc计算偏移距离</li><li>绝对定位、相对定位、margin计算偏移距离</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">        //<span class="attribute">margin</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-css">    .inner &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">        //<span class="attribute">transform</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//flex 布局</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//grid布局</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//table布局</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vertical-align 只对 table-cell起作用，vertical-align 的值是相对于其父元素的，父元素必须是行内元素。<br>对于一行文字来讲，该属性的值是相对于行高（line-height）的。<br>对于 table-cell，该属性的值是相对于表格的行高的。</p><h2 id="行内元素垂直居中、水平居中"><a href="#行内元素垂直居中、水平居中" class="headerlink" title="行内元素垂直居中、水平居中"></a>行内元素垂直居中、水平居中</h2><h3 id="垂直居中-1"><a href="#垂直居中-1" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>在行内元素的父元素设置：text-align: center;</li><li>flex布局：在行内元素的父元素设置：display: flex;justify-content: center;</li></ul><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p><strong>单行文本</strong></p><ul><li>把 line-height 设置为父元素的高度</li><li>flex布局：在行内元素的父元素设置：display: flex;align-items: center;<br><strong>多行文本</strong></li><li>在父元素设置： disaply: table-cell; vertical-align: middle; （多行文本垂直居中也适合单行文本的垂直居中）</li></ul><h2 id="实现单行／多行文本溢出的省略样式"><a href="#实现单行／多行文本溢出的省略样式" class="headerlink" title="实现单行／多行文本溢出的省略样式"></a>实现单行／多行文本溢出的省略样式</h2><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><p>实现方式也很简单，涉及的css属性有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-overflow</span>：ellipsis;</span><br><span class="line"><span class="attribute">white-space</span>：nowrap;</span><br><span class="line"><span class="attribute">overflow</span>：hidden;</span><br></pre></td></tr></table></figure><p>overflow设为hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略<br>white-space:nowrap，作用是设置文本不换行，是overflow:hidden和text-overflow：ellipsis生效的基础<br>text-overflow属性值有如下：clip：当对象内文本溢出部分裁切掉,ellipsis：当对象内文本溢出时显示省略标记（…）</p><h3 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h3><p>多行文本溢出的时候，我们可以分为两种情况：基于高度截断、基于行数截断</p><h4 id="基于高度截断"><a href="#基于高度截断" class="headerlink" title="基于高度截断"></a>基于高度截断</h4><ul><li>伪元素 + 定位<br>代码结构如下</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.demo</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">content</span>: <span class="string">&quot;...&quot;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;demo&#x27;</span>&gt;</span>这是一段很长的文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于行数截断"><a href="#基于行数截断" class="headerlink" title="基于行数截断"></a>基于行数截断</h4><ul><li>css</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">1px</span> solid red;</span><br><span class="line">        -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">        //用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的WebKit属性）</span><br><span class="line">        <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">        //将对象作为弹性伸缩盒子模型显示</span><br><span class="line">        -webkit-box-orient: vertical;</span><br><span class="line">        //设置或检索伸缩盒对象的子元素的排列方式</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;//文本溢出限定的宽度就隐藏内容</span><br><span class="line">        <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">        //多行文本的情况下，用省略号“…”隐藏溢出范围的文本</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">&lt;/<span class="selector-tag">p</span> &gt;</span><br></pre></td></tr></table></figure><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="媒体查询作用"><a href="#媒体查询作用" class="headerlink" title="媒体查询作用"></a>媒体查询作用</h3><ul><li>使用 @media查询,可以针对不同的媒体类型定义不同的样式;</li><li>@media 可以针对不同的屏幕尺寸设置不同的样式;</li><li>当重置浏览器大小的过程中,页面也会根据浏览器的宽度和高度重新渲染页面;</li><li>目前针对很多苹果手机、 Android手机 ,平板等设备都用得到多媒体查询。</li></ul><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123;</span><br><span class="line">CSS-<span class="selector-tag">Code</span>;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">1</span>.用<span class="keyword">@media</span>开头；</span><br><span class="line">// <span class="number">2</span>.mediatype媒体类型；</span><br><span class="line">// <span class="number">3</span>.关键字<span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">only</span></span><br><span class="line">// <span class="number">4</span>.media feature媒体特性，必须有小括号包含</span><br></pre></td></tr></table></figure><h3 id="mediatype查询类型"><a href="#mediatype查询类型" class="headerlink" title="mediatype查询类型"></a>mediatype查询类型</h3><p>将不同的终端设备分为不同的类型</p><p><img src="https://img-blog.csdnimg.cn/62e73f971dcd40738f521e5ab64c4efd.png#pic_center" alt="mediatype查询类型"></p><p><strong>mediatype查询类型</strong></p><h3 id="and-not-only"><a href="#and-not-only" class="headerlink" title="and|not|only"></a>and|not|only</h3><p>关键字将媒体类型或多个特性连接到一起做为媒体查询的条件</p><ul><li>and：可以将多个媒体特性连接到一起，相当”且”于的意思</li><li>not：排除某个媒体类型，相当于”非”的意思，可以省略</li><li>only：指定某个特定的媒体类型，可省略</li></ul><h3 id="media-feature"><a href="#media-feature" class="headerlink" title="media feature"></a>media feature</h3><p><img src="https://img-blog.csdnimg.cn/3ea213eb798242c2b3eb8351696ac21e.png#pic_center" alt="media feature"></p><p><strong>media feature</strong></p><p><img src="https://img-blog.csdnimg.cn/c897e47cefce4cb0ba1d2b7501097435.png#pic_center" alt="示例"></p><h2 id="rem、em、px、vh、vw-的区别"><a href="#rem、em、px、vh、vw-的区别" class="headerlink" title="rem、em、px、vh、vw 的区别"></a>rem、em、px、vh、vw 的区别</h2><ul><li>px相对长度单位。像素px是<strong>相对于显示器屏幕分辨率</strong>而言的。</li><li>%相对长度单位。相对于自己的父级。</li><li>em相对长度单位。基准点为<strong>父节点字体</strong>的大小，即相对于当前对象内文本的字体尺寸（继承父节点字体大小）。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸( 16px )。</li><li>rem相对长度单位。r’是“root”的缩写，相对于<strong>根元素html</strong>的字体大小。</li><li>vh and vw：<strong>相对于视口的高度和宽度</strong>，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。</li><li>vmin and vmax：取视口高度和宽度两者的最小值或者最大值，以最小或大进行百分比的计算。</li><li>pt 设备像素（物理像素）</li><li>dpr = 设备像素 / 设备独立像素</li><li>ppi 每英寸像素，值越大，图像越清晰</li></ul><h2 id="canvas与svg的区别"><a href="#canvas与svg的区别" class="headerlink" title="canvas与svg的区别"></a>canvas与svg的区别</h2><h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><p>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)。<br>SVG 用来定义用于网络的基于矢量的图形。<br>SVG 使用 XML 格式定义图形。<br>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失。<br>SVG 是万维网联盟的标准。<br>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。<br>知道了svg和canvas是什么之后，我们就来比较一下canvas和svg。</p><h3 id="canvas和svg的区别比较"><a href="#canvas和svg的区别比较" class="headerlink" title="canvas和svg的区别比较"></a>canvas和svg的区别比较</h3><p><strong>首先我们从时间上看canvas与svg的区别：</strong><br>canvas是html5提供的新元素</p><p><strong>其次我们从功能上看canvas与svg的区别：</strong><br>SVG 是一种使用 <strong>XML</strong> 描述 2D 图形的语言。<br>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。<br>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>Canvas 通过 <strong>JavaScript</strong> 来绘制 2D 图形。<br>Canvas 是逐像素进行渲染的。<br>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><p><strong>最后我们来看canvas与svg技术应用上的比较：</strong></p><ul><li>canvas不依赖分辨率, svg依赖分辨率。。</li><li>canvas支持事件处理器, svg支持。</li><li>canvas最适合带有大型渲染区域的应用程序（比如谷歌地图），svg弱的文本渲染能力。</li><li>canvas复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）。</li><li>canvas不适合游戏应用，svg最适合图像密集型的游戏，其中的许多对象会被频繁重绘。</li></ul><h2 id="继承相关"><a href="#继承相关" class="headerlink" title="继承相关"></a>继承相关</h2><p>css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解<br>释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。</p><h3 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h3><ol><li>display：规定元素应该生成的框的类型</li><li>文本属性：<br>vertical-align：垂直文本对齐<br>text-decoration：规定添加到文本的装饰<br>text-shadow：文本阴影效果<br>white-space：空白符的处理<br>unicode-bidi：设置文本的方向</li><li>盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</li><li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li>生成内容属性：content、counter-reset、counter-increment</li><li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li><li>页面样式属性：size、page-break-before、page-break-after</li><li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><h3 id="有继承性的属性"><a href="#有继承性的属性" class="headerlink" title="有继承性的属性"></a>有继承性的属性</h3><ol><li>字体系列属性<br>font：组合字体<br>font-family：规定元素的字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格<br>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。<br>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。<br>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</li><li>文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：增加或减少单词间的空白（即字间隔）<br>letter-spacing：增加或减少字符间的空白（字符间距）<br>text-transform：控制文本大小写<br>direction：规定文本的书写方向<br>color：文本颜色 a元素除外</li><li>元素可见性：visibility</li><li>表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</li><li>列表布局属性：list-style-type、list-style-image、list-style-position、list-style</li><li>生成内容属性：quotes</li><li>光标属性：cursor</li><li>页面样式属性：page、page-break-inside、windows、orphans</li><li>声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation</li></ol><h3 id="所有元素可以继承的属性"><a href="#所有元素可以继承的属性" class="headerlink" title="所有元素可以继承的属性"></a>所有元素可以继承的属性</h3><ol><li>元素可见性：visibility</li><li>光标属性：cursor</li></ol><h3 id="内联元素可以继承的属性"><a href="#内联元素可以继承的属性" class="headerlink" title="内联元素可以继承的属性"></a>内联元素可以继承的属性</h3><ol><li>字体系列属性</li><li>除text-indent、text-align之外的文本系列属性</li></ol><h3 id="块级元素可以继承的属性"><a href="#块级元素可以继承的属性" class="headerlink" title="块级元素可以继承的属性"></a>块级元素可以继承的属性</h3><ol><li>text-indent、text-align</li></ol><h2 id="css预处理工具"><a href="#css预处理工具" class="headerlink" title="css预处理工具"></a>css预处理工具</h2><p>CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。<br>css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；它们各自的背景如下:<br><strong>Sass：</strong><br>2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。<br><strong>Less：</strong><br>2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。<br><strong>Stylus：</strong><br>2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。</p><h3 id="less-和scss区别"><a href="#less-和scss区别" class="headerlink" title="less 和scss区别"></a>less 和scss区别</h3><p>相同点：</p><ul><li>LESS和SCSS都是css的预处理器，可以拥有变量，运算，继承，嵌套的功能，使用两者可以使代码更加的便于阅读和维护。</li><li>都可以通过自带的插件，转成相对应的css文件。</li><li>都可以参数混入，可以传递参数的class，就像函数一样</li><li>嵌套的规则相同，都是class嵌套class</li></ul><p>不同点：</p><ul><li>声明和使用变量LESS用@符号，SCSS用$符号表示</li><li>变量插值LESS采用@{XXXX}的形式，SCSS采用${XXXX}的形式</li><li>less不支持条件语句，scss支持条件语句</li><li>引用外部css文件方式不同 scss引用的css文件名必须以‘_’开头（下划线），文件名如果以下划线开头的话，sass会认为改文件是一个应用文件，不会将它转成css文件</li><li>调整色相的函数不一样，LESS使用spin（）的函数；SCSS使用名为adjust_hue()的函数</li><li>LESS和SCSS都可以使用&amp;符号表示父选择器，但是SCSS的&amp;符号只能出现在一个组合选择器的开始位置，LESS则没有这个限制</li></ul><p>总结：<br>SCSS和LESS都是一种基于css之上的高级语言，两者之间各有优点，sass在功能上面比LESS更强大，LESS比较的清晰明了，容易上手，主要是看大家的工作中，更倾向于使用那个进行开发，两者都能够大大提高书写代码的效率</p><h2 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h2><p><strong>块级元素</strong></p><ol><li>总是从新的一行开始，即各个块级元素独占一行，默认垂直向下排列；</li><li>高度、宽度、margin及padding都是可控的，设置有效，有边距效果；</li><li>宽度没有设置时，默认为100%；</li><li>块级元素中可以包含块级元素和行内元素。</li></ol><p><strong>行内元素</strong></p><ol><li>和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列；</li><li>高度、宽度是不可控的，设置无效，由内容决定。</li><li>根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素。<br>转换</li></ol><p>当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。<br>使用display属性能够将三者任意转换：<br>(1)display:inline;转换为行内元素；<br>(2)display:block;转换为块状元素；<br>(3)display:inline-block;转换为行内块状元素。<br>当使用display:inline-block</p><h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p><strong>重绘</strong>: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p><p><strong>回流</strong>：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</p><ul><li>添加或者删除可见的 DOM 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 input 框中输入文字</li><li>浏览器窗口尺寸改变——resize事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>当你修改网页的默认字体时。</li></ul><h3 id="为什么有时候用translate而不是用绝对定位来改变位置"><a href="#为什么有时候用translate而不是用绝对定位来改变位置" class="headerlink" title="为什么有时候用translate而不是用绝对定位来改变位置"></a>为什么有时候用translate而不是用绝对定位来改变位置</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重排（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重排，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h2 id="隐藏一个元素的几种方法"><a href="#隐藏一个元素的几种方法" class="headerlink" title="隐藏一个元素的几种方法"></a>隐藏一个元素的几种方法</h2><ol><li>display:none 隐藏后不占据空间 会产生回流和重绘 不会被子元素继承，同时在渲染树中消失，但在dom树依然存在</li><li>visibility:hidden 隐藏后依旧占据空间 所以只会产生重绘 会被子元素继承，在渲染树、dom树都存在</li><li>opacity:0 隐藏后依旧占据空间 所以只会产生重绘 会被子元素继承</li><li>width:0 height:0</li></ol><h2 id="一个按钮，一直固定在在窗口的右边"><a href="#一个按钮，一直固定在在窗口的右边" class="headerlink" title="一个按钮，一直固定在在窗口的右边"></a>一个按钮，一直固定在在窗口的右边</h2><ol><li>float:left</li><li>display:flex;justify-content:flex-start</li><li>position:fixed</li></ol><h2 id="盒模型-1"><a href="#盒模型-1" class="headerlink" title="盒模型"></a>盒模型</h2><p>CSS3中的盒模型有以下两种:标准盒模型、IE盒模型<br>盒模型都是由四个部分组成的,分别是margin、border、padding和content<br>标准盒模型和IE盒模型的区别在于设置width和height时, 所对应的范围不同</p><ol><li>标准盒模型的width和height属性的范围只包含了content</li><li>IE盒模型的width和height属性的范围包含了border、padding和content<br>可以通过修改元素的box-sizing属性来改变元素的盒模型；</li><li>box-sizing：content-box表示标准盒模型（默认值）</li><li>box-sizing：border-box表示IE盒模型（怪异盒模型）</li></ol><h2 id="block、inline-block、inline"><a href="#block、inline-block、inline" class="headerlink" title="block、inline-block、inline"></a>block、inline-block、inline</h2><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>块级元素：元素呈现“块”状，有自己的宽度和高度，也就是<strong>可以设置宽(width)和高(height)，除此之外，独自占据一行高度</strong>（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p><p>每个块级元素都是独自占一行。<br>元素的高度(height)、宽度(width)、行高(line-height)和边距(margin、padding)都是可以设置的。　　<br>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）。<br>常见块级元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>、<span class="tag">&lt;<span class="name">address</span>&gt;</span>、 <span class="tag">&lt;<span class="name">caption</span>&gt;</span>、<span class="tag">&lt;<span class="name">dd</span>&gt;</span>、<span class="tag">&lt;<span class="name">div</span>&gt;</span>、<span class="tag">&lt;<span class="name">dl</span>&gt;</span>、<span class="tag">&lt;<span class="name">dt</span>&gt;</span>、<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>、<span class="tag">&lt;<span class="name">form</span>&gt;</span>、<span class="tag">&lt;<span class="name">h1</span>&gt;</span>～<span class="tag">&lt;<span class="name">h6</span>&gt;</span>、<span class="tag">&lt;<span class="name">hr</span>&gt;</span>、 <span class="tag">&lt;<span class="name">legend</span>&gt;</span>、<span class="tag">&lt;<span class="name">li</span>&gt;</span>、<span class="tag">&lt;<span class="name">noframes</span>&gt;</span>、<span class="tag">&lt;<span class="name">noscript</span>&gt;</span>、<span class="tag">&lt;<span class="name">ol</span>&gt;</span>、<span class="tag">&lt;<span class="name">ul</span>&gt;</span>、<span class="tag">&lt;<span class="name">p</span>&gt;</span>、<span class="tag">&lt;<span class="name">pre</span>&gt;</span>、<span class="tag">&lt;<span class="name">table</span>&gt;</span>、<span class="tag">&lt;<span class="name">tbody</span>&gt;</span>、<span class="tag">&lt;<span class="name">td</span>&gt;</span>、<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>、<span class="tag">&lt;<span class="name">th</span>&gt;</span>、<span class="tag">&lt;<span class="name">thead</span>&gt;</span>、<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：块级元素内能嵌套块级元素、行内元素。但是h1-h6、p、dt这几个块级元素不能嵌套块级元素。</p><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>行内元素<strong>不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行</strong>,行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。行内元素有以下特点： </p><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。<br>行内元素的高度(height)、宽度(width)、行高(line-height)及内、外边距的底和顶边距(margin-top、padding-top、margin-bottom、padding-bottom)不可设置。<br>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p><h2 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h2><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，<strong>它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。</strong>比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p><p>和其他行内或行内块级元素元素放置在同一行上；<br>元素的高度、宽度、行高以及顶和底边距都可设置。<br>注意：img和input元素虽然属于行内元素，但是又可以细分为行内替换元素。所以它表现的像行内块级元素一样。</p><h2 id="浮动模型及清除浮动的方法"><a href="#浮动模型及清除浮动的方法" class="headerlink" title="浮动模型及清除浮动的方法"></a>浮动模型及清除浮动的方法</h2><p>浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。<br>float：none/left/right<br>浮动会脱离文档流（文字流不会脱离），所以浮动会导致父元素高度坍塌</p><p>如何清除浮动</p><ol><li>固定宽高<br>给浮动的元素添加父级div盒子,再给父级盒子设置高度<br>缺点:高度固定死了,无法做到自适应,不宜维护,不灵活<br>应用:万年不变导航栏,固定栏;</li><li>一起浮动<br>父元素也添加浮动,这样父元素也脱离文档流<br>缺点:这是一种将错就错的办法,后面的DIV盒子依然会塌陷到浮动元素下面</li><li>额外标签法<br>在浮动的元素最后添加一个空div标签,里面设置style=’clear:both’;触发bfc机制<br>优点： 通俗易懂，书写方便<br>缺点： 添加许多无意义的标签，结构化较差<br>注意： 要求这个新的空标签必须是块级元素。</li><li>父级添加伪元素</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案</span><br><span class="line">// 引入了zoom以支持IE6/<span class="number">7</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：没有增加标签，结构更简单<br>代表网站： 百度、淘宝网、网易等</p><ol><li>父级添加双伪元素</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案【推荐】</span><br><span class="line">// 引入了zoom以支持IE6/<span class="number">7</span></span><br><span class="line">// 同时加入<span class="selector-pseudo">:before</span>以解决现代浏览器上边距折叠的问题</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>父盒子添加overflow: hidden;触发BFC</li><li>父盒子添加position:absolute;触发BFC，但同时父盒子也会脱离文档流</li></ol><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。</p><p>W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。<br>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。</p><p><strong>怎样触发BFC</strong></p><ul><li>overflow: hidden</li><li>display: inline-block</li><li>position: absolute</li><li>position: fixed</li><li>display: table-cell</li><li>display: flex</li></ul><p>BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列<br>BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签。垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠。计算BFC的高度时，浮动元素也参与计算</p><p><strong>BFC解决了什么问题</strong></p><ol><li>使用float脱离文档流，高度塌陷</li><li>margin边距重叠</li><li>两栏布局</li></ol><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>IFC（Inline Formatting Contexts）直译为”行级格式化上下文”，不受到竖直方向的 padding/margin 影响。</p><p><strong>如何触发IFC？</strong><br>块级元素中仅包含内联级别元素<br>形成条件非常简单，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个IFC。</p><p><strong>IFC布局规则</strong></p><ul><li>在一个IFC内，子元素是水平方向横向排列的，并且垂直方向起点为元素顶部。</li><li>子元素只会计算横向样式空间，【padding、border、margin】，垂直方向样式空间不会被计算，【padding、border、margin】。</li><li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li><li>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是包含块（containing box）和与其中的浮动来决定。</li><li>IFC中的line box一般左右边贴紧其包含块，但float元素会优先排列。</li><li>IFC中的line box高度由 CSS 行高计算规则来确定，同个IFC下的多个line box高度可能会不同。</li><li>当 inline boxes的总宽度少于包含它们的line box时，其水平渲染规则由 text-align 属性值来决定。</li><li>当一个inline box超过父元素的宽度时，它会被分割成多个boxes，这些boxes分布在多个line box中。如果子元素未设置强制换行的情况下，inline box将不可被分割，将会溢出父元素。</li></ul><p><strong>IFC应用场景</strong></p><ul><li>元素水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>多行文本水平垂直居中：创建一个IFC，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><h2 id="让整个页面变成灰色"><a href="#让整个页面变成灰色" class="headerlink" title="让整个页面变成灰色"></a>让整个页面变成灰色</h2><p>filter: grayscale(100%) 滤镜属性：100%的灰色</p><h2 id="让整个页面禁止点击事件"><a href="#让整个页面禁止点击事件" class="headerlink" title="让整个页面禁止点击事件"></a>让整个页面禁止点击事件</h2><p>pointer-events:none<br>让元素永远无法成为鼠标事件的target，进而禁止鼠标事件即可。</p><h2 id="margin坍塌"><a href="#margin坍塌" class="headerlink" title="margin坍塌"></a>margin坍塌</h2><p><strong>margin塌陷现象：</strong>在垂直方向如果有两个元素的外边距有相遇，在浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值比较大的，边距小的塌陷到了边距值大的值内部。</p><ol><li>同级元素塌陷：上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正盒子间距离是较大的那个值。<br>盒子box1的下边距依然存在，只是不显示了，由此可见边距小的塌陷到了边距值大的值内部，所以间距为box2的边距100px。</li><li>父子元素塌陷：父子元素之间也会出现margin塌陷，（1）父元素和子元素都设置了同方向的margin-top值，两个属性之间没有其他内容进行隔离，导致两个属性相遇，发生margin塌陷。（2）本身父元素与上一个元素的距离是0，子元素如果设置了垂直方向的上边距，会带着父级元素一起掉下来（父元素的上边距0塌陷到了子元素的上边距50里面）。</li></ol><p><strong>解决方法：</strong></p><ol><li>同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。</li><li>父子元素：让两个边距不要相遇，中间可以使用父元素border或padding将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用子元素的margin去设置，而是用父元素的padding挤出来。</li></ol><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>布局实现的目的<br>1.三列布局，两端固定宽度(其实可以不用固定宽度），中间栏自适应。<br>2.中间栏优先渲染。<br>3.任意栏高度自由不限制。</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>三栏全部float:left浮动，区别在于解决中间栏div的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合left和right属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-width</span>: <span class="number">550px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#header</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:darkgrey;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-right</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">//为了让中间的子盒子的内容不被遮挡住，设置了<span class="attribute">padding-left</span>与<span class="attribute">padding</span>-rigth，</span></span><br><span class="line"><span class="language-css">//配合设置左右子盒子的<span class="attribute">margin-left</span>（左盒子百分比 -<span class="number">100%</span> ）与<span class="attribute">margin-right</span>（右盒子数值 -<span class="number">150px</span>），</span></span><br><span class="line"><span class="language-css">//同时还需要设置<span class="attribute">position</span>: relative与right: -<span class="number">150px</span></span></span><br><span class="line"><span class="language-css">#middle &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#left</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">right</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-right</span>: -<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">right</span>: -<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:darkgrey;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.column</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局是在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是100%宽度，只不过中间栏的内容通过margin的值显示在中间。大概可以用下面这张图表示：</p><p><img src="https://img-blog.csdnimg.cn/20190307213240959.png" alt="区别"></p><p><strong>区别</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#header</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:darkgrey;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#middle</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-right</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">//为了中间盒子的内容不被遮挡，给中间盒子设置<span class="attribute">margin-left</span>与<span class="attribute">margin-right</span>，为左右盒子流出位置</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#left</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#right</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:darkgrey;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.column</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="css引入"><a href="#css引入" class="headerlink" title="css引入"></a>css引入</h2><ol><li>行内样式、内联样式 在网页元素上通过style=””属性</li><li>内部样式表 在网页创建嵌入的样式表，写在里面</li><li>链入外部样式表 网页引入外部样式表，外部创建一个css文件，在html中通过连接这个css文件，一般写在css前面</li><li>导入外部样式表 通过@import 引入，不建议开发使用</li></ol><p><strong>css引用的优先级</strong><br>记住就近原则<br>内部样式、@import都出现在HTML的里面，就近原则，距离修改元素近的优先级高<br><strong>行内样式&gt;内部样式&gt;link&gt;@import</strong><br>建议开发中链入外部样式，无需改动HTML结构，有利于代码的维护，开发效率高</p><p><strong>link和@import的区别</strong></p><ol><li>引入的内容不同<br>link引入样式文件、图片资源等，而@import只引入样式文件</li><li>加载的顺序不同<br>link在页面加载的同时加载，@import在页面加载以后加载</li><li>兼容性不同<br>link是XHTML标签，没有兼容性问题，@import在css2.1提出，低版本的浏览器不支持</li><li>对js的支持不同<br>link支持js控制dom去改变样式，@import则不能支持</li></ol><h2 id="css-z-index优先级"><a href="#css-z-index优先级" class="headerlink" title="css z-index优先级"></a>css z-index优先级</h2><p><a href="https://blog.csdn.net/weixin_42878211/article/details/114934078">z-index优先级</a></p><p>z-index的基础概念<br>x 轴代表水平方向，y 轴代表垂直方向，z 轴则代表我们的目光向页面（屏幕）看进去的时候，各元素的布局情况。</p><p>屏幕是一个二维平面，所以完美实际上是看不到z轴的，z轴实际上是通过透视的形式展示的。也就是说，多个元素共享同一块二维平民啊时，友得元素在顶部，有的元素在底部，因此而感受到z轴的存在。</p><p>css允许我们给z-index设置三种值来决定某个元素在z轴方向上的位置。</p><p>auto（默认值） 堆叠顺序与父元素相等<br>number 元素的堆叠顺序<br>inherit 规定应该从父元素继承z-index属性的值<br>主要来看一下它的number值，number可以为正整数，负整数或者0，值越大的话，元素就会距离我们的眼睛越近，值越小就会距离我们的眼睛越远。</p><p>如果两个元素在定位之后共享同一块二维空间，那么在这块空间中，z-index越大的元素将会覆盖z-index较小的元素。</p><p>层叠顺序<br>我们可以通过一个非常简单的例子来理解层叠顺序，这个例子甚至还不需要涉及到 定位元素 。</p><p>想象一下，现在有一个非常简单的网页，不考虑默认等元素，就只需要考虑每个网页至少都会有的一个 div。在 CSS 文件中设置 html 的背景颜色为蓝色，设置 div 的背景颜色为红色，并设置宽高。</p><p>当加载页面的时候，你觉得会看到什么？</p><p>这个自然不用多想，引入眼帘的肯定是一大片的蓝色，同时还有一个此前设置好尺寸的红色块级元素。除非你做了额外的设置，否则这个元素将正常地出现在左上角。</p><p>为什么红色的块级元素就一定会位于蓝色背景的上层呢？为什么我们看到的就是 div 位于 html 的上层呢？原因是，它们都遵循了层叠顺序的规则。</p><p>在这个简单的例子中，根据规则，正常文档流的子块（div）的层级将会高于根元素（html）的背景和边框。我们看到div 位于顶层，这是因为它的层叠等级更高。</p><p><img src="https://img-blog.csdnimg.cn/20201114203435700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU1NTc3NA==,size_16,color_FFFFFF,t_70#pic_center" alt="层叠上下文"></p><p><strong>层叠上下文</strong></p><p>虽然上面这个例子只涉及到了两个层叠等级，但实际上，在一个层叠上下文中，一共可能出现七个层叠等级，从最低到最高排列，依次是：</p><ol><li>背景和边框 ：形成层叠上下文的元素的背景和边框，它是整个上下文中层叠等级最低的</li><li>Z-index 为负数 ：设置了 z-index 为负数的子元素以及由它所产生的层叠上下文</li><li>块级盒模型：位于正常文档流中的、块级的、非定位的子元素</li><li>浮动盒模型 ：浮动的、非定位的子元素</li><li>内联盒模型 ：位于正常文档流中的、内联的、非定位的子元素</li><li>Z-index 为 0：设置了 z-index 为 0 与auto 的、定位的子元素以及由它所产生的层叠上下文</li><li>Z-Index 为正数 ：设置了 z-index 为正数的、定位的子元素以及由它所产生的层叠上下文，它是整个上下文中层叠等级最高的</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2023/03/31/html/"/>
      <url>/2023/03/31/html/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>HTML5的设计目的是为了在<strong>移动设备</strong>上支持多媒体。</p><p>在HTML5出来之前，我们习惯于用没有语义的<strong>div</strong>来表示不同模块。</p><p>在HTML5中加入了一些<strong>语义化</strong>标签，来更清晰的表达<strong>文档结构</strong>。</p><h3 id="H5新特性："><a href="#H5新特性：" class="headerlink" title="H5新特性："></a>H5新特性：</h3><ol><li>拖拽释放（drag and drop）API</li><li>语义化更好的内容标签（header footer nav aside article section）</li><li>音频. 视频（audio video）API</li><li>画布（Canvas）API</li><li>地理（Geolocation）API</li><li>localstorage 和 sessionstorage 缓存方式</li><li>表单控件（calendar date time email ul search）</li><li>新技术（webworker websocket Geolocation）</li></ol><h3 id="H5移除的元素"><a href="#H5移除的元素" class="headerlink" title="H5移除的元素"></a>H5移除的元素</h3><ol><li>纯表现元素：basefont font big center s tt u strike</li><li>对可用性有负面影响的元素：frame frameset noframes</li></ol><h2 id="script标签中的defer和async的区别"><a href="#script标签中的defer和async的区别" class="headerlink" title="script标签中的defer和async的区别"></a>script标签中的defer和async的区别</h2><ul><li>script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li><li>async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li><li>defer script：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li></ul><p><img src="https://zyhxwing.gitee.io/images/html/1399.png" alt="区别"></p><h2 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h2><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好的解析。<br><strong>为了在没有CSS的情况下，页面也能呈现出很好的内容结构和代码结构。</strong></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字饿权重）</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化</li></ul><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ol><li>尽可能少的使用无语义的标签div和span</li><li>在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利</li><li>不要使用纯样式标签，如：b、font、u等，改用CSS设置</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用css指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和单元格要区分开，表头用th，单元格用td</li><li>表单域要用fieldset标签抱起来，并用legend标签说明表单的用途</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在label标签中设置for=someId来让说明文本和相对应的input关联起来</li></ol><p><strong>常见的语义化标签：</strong>article（定义文章）、aside（定义文章的侧边栏）、figure（一组媒体对象以及文字）、figurecaption（定义figure的标题）、footer（定义页脚）、header（定义页眉）、nav（定义导航栏）、section（定义文档中的区段）、time（定义日期和时间）、dialog（定义一个对话框）</p><h2 id="浏览器渲染页面的一般过程"><a href="#浏览器渲染页面的一般过程" class="headerlink" title="浏览器渲染页面的一般过程"></a>浏览器渲染页面的一般过程</h2><ol><li>浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</li><li>浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</li><li>DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</li></ol><p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p><ol><li>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</li></ol><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><h2 id="获取dom元素的方法"><a href="#获取dom元素的方法" class="headerlink" title="获取dom元素的方法"></a>获取dom元素的方法</h2><ol><li><p>querySelector</p><p><code>document.querySelector(‘选择器’)</code><br>在指定上下文中通过选择器获取第一个元素（只能获取一个），获取不到就是null</p></li><li><p>querySelectorAll</p><p><code>document.querySelectorAll(‘选择器’)</code><br>在指定上下文中通过选择器获取一组元素集合，获取不到就是空元（通过数组方法取元素）</p></li><li><p>getElementById</p><p><code>document.getElementByid(&#39;id名&#39;)</code><br>在document上下文下获取元素(通过Id获取的元素是一个元素对象，获取不到就是null)getElementByTagName</p></li><li><p>getElementByTagName</p><p><code>document.getElementByTagName(‘标签名’)</code><br>通过指定的上下文获取指定的标签，获取的是一个元素集合，如果没有获取到元素，那就是空元素集合 (通过数组方法取元素）</p></li><li><p>getElementByName</p><p><code>document.getElementByName(‘标签名’)</code><br>在整个文档中，通过标签的NAME属性值获取一组节点集合（在IE中只有表单元素的NAME才能识别，所以我们一般应用于表单元素的处理）</p></li><li><p>getElementClassName</p><p><code>document.getElementClassName(‘类名’)</code><br>在整个文档中，通过标签的NAME属性值获取一组节点集合（在IE中只有表单元素的NAME才能识别，所以我们一般应用于表单元素的处理）</p></li><li><p>document.body</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(body);</span><br></pre></td></tr></table></figure><p>body 属性用于设置或返回文档体。<br>如果是返回, 该属性返回当前文档的 body 元素。<br>如果是设置, 该属性会覆盖所有在 body 元素中的子元素, 并用新的内容来替换它</p></li><li><p>document.documentElement</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html=<span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html);</span><br></pre></td></tr></table></figure><p>documentElement 属性以一个元素对象返回一个文档的文档元素。<br>HTML 文档返回对象为HTML元素。<br>注意： 如果 HTML 元素缺失，返回值为 null。</p></li></ol><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p><a href="https://so.csdn.net/so/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80&spm=1001.2101.3001.7020">响应式布局</a>指的是<strong>同一页面</strong>在<strong>不同屏幕尺寸</strong>下有<strong>不同的布局</strong>。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。</p><ul><li>使用媒体<strong>查询</strong>（@media）：使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。</li><li>使用flex<strong>弹性</strong>布局：弹性布局是一种十分方便的，只需要依赖于CSS样式的实现响应式布局的方式，也是最多用到的一种实现响应式的方法。</li><li>使用<strong>百分比</strong>单位：通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。</li><li>rem单位：rem单位是相对于字体大小的html元素，也称为根元素。 默认情况下，html元素的font-size为16px。所以此时1rem = 16px。</li><li>VH、HW单位：css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。</li></ul><h2 id="回流（重排）和重绘"><a href="#回流（重排）和重绘" class="headerlink" title="回流（重排）和重绘"></a>回流（<strong>重排</strong>）和重绘</h2><p><strong>回流（重排）</strong></p><p>元素的的位置和尺寸大小发生变化，导致需要重新构建页面的时候</p><ul><li>增删可见的 DOM 元素的时候</li><li>元素的位置发生改变</li><li>元素的尺寸发生改变</li><li>内容改变</li><li>页面第一次渲染的时候</li></ul><p><strong>重绘</strong></p><p>外观发生改变，但没有改变布局</p><p>列举一些相关的 CSS 样式：color、background、background-size、visibility、box-shadow</p><h2 id="Web标准和W3C标准"><a href="#Web标准和W3C标准" class="headerlink" title="Web标准和W3C标准"></a>Web标准和W3C标准</h2><p><strong>网页组成</strong></p><p>web标准</p><p><img src="/2023/03/31/html/image-20230331114334751.png" alt="web标准"></p><ul><li><p>结构（骨架）：HTML用于描述页面的结构</p></li><li><p>表现（皮肤）：CSS用于控制页面中元素的样式</p></li><li><p>行为（交互）：JavaScript用于响应用户操作</p></li><li><p>W3C：World Wide Web（万维网） Consortium，对web标准提出了代码规范的要求</p></li><li><p>对结构的要求1、标签字母要小写2、标签要闭合</p></li><li><p>对行为的要求</p><p>1、建议使用<strong>外链CSS和js脚本</strong>，实现<strong>结构与表现分离</strong>、<strong>结构与行为分离</strong>，能提高页面的<strong>渲染效率</strong>，更快地显示网页内容</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2023/03/29/vue/"/>
      <url>/2023/03/29/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p><h2 id="Vue响应式数据原理"><a href="#Vue响应式数据原理" class="headerlink" title="Vue响应式数据原理"></a>Vue响应式数据原理</h2><p>首先需要解释的是 什么是响应式：数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。</p><h3 id="Vue2-x响应式数据原理"><a href="#Vue2-x响应式数据原理" class="headerlink" title="Vue2.x响应式数据原理"></a>Vue2.x响应式数据原理</h3><p>Vue2.x采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，在初始化的时候，通过Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的依赖收集器 subs，逐个通知 watcher，视图开始更新。</p><p><img src="https://zyhxwing.gitee.io/images/Vue/1371_1.png" alt="Vue2.x响应式数据原理"></p><h3 id="Vue2-x如何监听数组变化"><a href="#Vue2-x如何监听数组变化" class="headerlink" title="Vue2.x如何监听数组变化"></a>Vue2.x如何监听数组变化</h3><p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><h3 id="Vue3-x响应式数据原理"><a href="#Vue3-x响应式数据原理" class="headerlink" title="Vue3.x响应式数据原理"></a>Vue3.x响应式数据原理</h3><p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法，包括不限于 apply、ownKeys、deleteProperty、has 等等。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><p>但是Proxy只会代理对象的第一层，Vue3会判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p><p>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</p><p>我们可以判断当前检测的属性是否为当前被代理对象的自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才会触发。</p><h3 id="Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？"><a href="#Vue3-0-里为什么要用-Proxy-API替代-defineProperty-API？" class="headerlink" title="Vue3.0 里为什么要用 Proxy API替代 defineProperty API？"></a>Vue3.0 里为什么要用 Proxy API替代 defineProperty API？</h3><p>1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。<br>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。</p><p>2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>3.响应式是惰性的。<br>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</p><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><ul><li>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的<strong>数据和方法都不能被访问</strong>。</li><li>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是<strong>可以使用数据，更改数据</strong>，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段<strong>Dom还没有创建</strong>，无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</li><li>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段<strong>虚拟Dom已经创建完成，即将开始渲染</strong>。在此时也可以对数据进行更改，不会触发updated。</li><li>mounted在挂载完成后发生，在当前阶段，<strong>真实的Dom挂载完毕</strong>，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。<br><strong>接口请求一般放在mounted中，但需要注意的是服务端渲染时不支持mounted，需要放到created中。</strong></li><li>beforeUpdate发生在更新之前，也就是<strong>响应式数据发生更新，虚拟dom重新渲染之前被触发</strong>，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated发生在更新完成之后，当前阶段组件<strong>Dom已完成更新</strong>。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy发生<strong>在实例销毁之前，在当前阶段实例完全可以被使用</strong>，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed发生在<strong>实例销毁之后，这个时候只剩下了dom空壳</strong>。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ul><h3 id="不常用的钩子"><a href="#不常用的钩子" class="headerlink" title="不常用的钩子"></a>不常用的钩子</h3><p>activated</p><ul><li>keep-alive 组件激活时调用，该钩子在服务器端渲染期间不被调用。</li></ul><p>deactivated</p><ul><li>keep-alive 组件停用时调用，该钩子在服务器端渲染期间不被调用。</li></ul><p>errorCaptured</p><ul><li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。</li></ul><h3 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h3><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><p>执行的先后顺序为<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p>父c-&gt;子c-&gt;子m-&gt;父m</p><p>子组件更新过程 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁过程 父beforeDestory-&gt;子beforeDestory-&gt;子destoryed-&gt;父destoryed</p><h2 id="Vue里Computed和Watch的区别"><a href="#Vue里Computed和Watch的区别" class="headerlink" title="Vue里Computed和Watch的区别"></a>Vue里Computed和Watch的区别</h2><p><strong>Computed</strong>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p><p><strong>Watch</strong>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。</p><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><p>相同点：<br>v-show和v-if都能控制元素的显示和隐藏。</p><p>不同点：<br>1.实现本质方法不同:v-show本质就是通过设置css中的display设置为none;控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素;<br>2.v-show都会编译，初始值为false，只是将display设为none，但它也编译了;v-if初始值为false，就不会编译了<br>总结：v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，如果要频繁切换某节点时，故v-show性能更好一点。</p><h2 id="为什么要避免v-if和v-for一起使用"><a href="#为什么要避免v-if和v-for一起使用" class="headerlink" title="为什么要避免v-if和v-for一起使用"></a>为什么要避免v-if和v-for一起使用</h2><p>vue2.x版本中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；<br>vue3.x版本中，当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。<br>官网明确指出：避免 v-if 和 v-for 一起使用，永远不要在一个元素上同时使用 v-if 和 v-for。</p><p>可以先对数据在计算数据中进行过滤，然后再进行遍历渲染；<br>操作和实现起来都没有什么问题，页面也会正常展示。但是会带来不必要的性能消耗；</p><h2 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h2><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</p><h2 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h2><p>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。</p><p>v-model 在内部为不同的输入元素使用不同的property并抛出不同的事件</p><ul><li>text和textarea 元素使用value property 和 input事件</li><li>checkbox 和radio使用checked property 和 change事件</li><li>select 字段将value 作为prop 并将change 作为事件</li></ul><h2 id="VUE中的事件绑定原理"><a href="#VUE中的事件绑定原理" class="headerlink" title="VUE中的事件绑定原理"></a>VUE中的事件绑定原理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生事件绑定</span></span><br><span class="line">&lt;div @click=<span class="string">&quot;fn()&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件绑定</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">&quot;fn&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;fn1&quot;</span>&gt;</span>&lt;/my- component&gt;</span></span><br></pre></td></tr></table></figure><h3 id="原生事件绑定"><a href="#原生事件绑定" class="headerlink" title="原生事件绑定"></a>原生事件绑定</h3><p>原生事件绑定是通过addEventListener绑定给真实元素的，</p><p>源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateDOMListeners</span> (<span class="attr">oldVnode</span>: <span class="title class_">VNodeWithData</span>, <span class="attr">vnode</span>: <span class="title class_">VNodeWithData</span>) &#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode.<span class="property">data</span>.<span class="property">on</span>) &amp;&amp; <span class="title function_">isUndef</span>(vnode.<span class="property">data</span>.<span class="property">on</span>)) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">const</span> on = vnode.<span class="property">data</span>.<span class="property">on</span> || &#123;&#125; <span class="keyword">const</span> oldOn = oldVnode.<span class="property">data</span>.<span class="property">on</span> || &#123;&#125; </span><br><span class="line">target = vnode.<span class="property">elm</span> </span><br><span class="line"><span class="title function_">normalizeEvents</span>(on) </span><br><span class="line"><span class="title function_">updateListeners</span>(on, oldOn, add, remove, createOnceHandler, vnode.<span class="property">context</span>) </span><br><span class="line">target = <span class="literal">undefined</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> ( </span><br><span class="line"><span class="attr">name</span>: string, </span><br><span class="line"><span class="attr">handler</span>: <span class="title class_">Function</span>, </span><br><span class="line"><span class="attr">capture</span>: boolean, </span><br><span class="line"><span class="attr">passive</span>: boolean </span><br><span class="line">) &#123;</span><br><span class="line">target.<span class="title function_">addEventListener</span>( <span class="comment">// 给当前的dom添加事件 </span></span><br><span class="line">name, </span><br><span class="line">handler, </span><br><span class="line">supportsPassive </span><br><span class="line">? &#123;  capture, passive  &#125; </span><br><span class="line">: capture </span><br><span class="line">) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件的事件绑定"><a href="#组件的事件绑定" class="headerlink" title="组件的事件绑定"></a>组件的事件绑定</h3><p>组件事件绑定是通过Vue自定义的$on实现的，（可用event触发）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateComponentListeners</span> ( </span><br><span class="line"><span class="attr">vm</span>: <span class="title class_">Component</span>, </span><br><span class="line"><span class="attr">listeners</span>: <span class="title class_">Object</span>, </span><br><span class="line"><span class="attr">oldListeners</span>: ?<span class="title class_">Object</span> </span><br><span class="line">) &#123;</span><br><span class="line">target = vm <span class="title function_">updateListeners</span>(</span><br><span class="line">listeners, oldListeners || &#123;&#125;, </span><br><span class="line">add, </span><br><span class="line">remove,</span><br><span class="line">createOnceHandler, vm)</span><br><span class="line">target = <span class="literal">undefined</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (event, fn) &#123; </span><br><span class="line">target.$on(event, fn) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h2><p>Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段：<br>首先解析模版，<strong>生成AST语法树</strong>(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。</p><p><strong>优化</strong>过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的AST树<strong>转换为可执行的代码</strong>。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM（Virtual Dom）即虚拟节点。虚拟DOM在Vue.js里做了两件事：</p><ul><li>创建JS对象（虚拟节点），用来模拟真实DOM节点，该对象包含了真实DOM的结构及其属性</li><li>将虚拟节点与旧虚拟节点进行对比，然后更新视图（渲染）</li></ul><h3 id="操作真实-DOM-的代价"><a href="#操作真实-DOM-的代价" class="headerlink" title="操作真实 DOM 的代价"></a>操作真实 DOM 的代价</h3><p>原生 JS 或 JQuery 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍渲染流程。</p><p>比如：在一次操作中，我要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。第一次计算完时，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。</p><p>计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。</p><p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性。</p><h3 id="虚拟-DOM-的好处"><a href="#虚拟-DOM-的好处" class="headerlink" title="虚拟 DOM 的好处"></a>虚拟 DOM 的好处</h3><p>虚拟DOM就是为了解决直接操作DOM导致的性能问题而被设计出来的。</p><p>使用了虚拟DOM之后，假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无用的计算量。</p><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个内存。既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个虚拟DOM。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p><p>Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p><h3 id="虚拟-DOM作用总结"><a href="#虚拟-DOM作用总结" class="headerlink" title="虚拟 DOM作用总结"></a>虚拟 DOM作用总结</h3><ul><li>提升渲染性能<br>操作 DOM 会导致渲染很慢（每次操作DOM都会触发回流和重绘）。<br>操作虚拟DOM实际是操作JS对象，可以将多次操作整合后再统一操作DOM。操作虚拟DOM时不会引起回流和重绘（即：不会引起渲染）</li><li>具备跨平台的优势<br>Virtual DOM 基于JavaScript 对象而不依赖真实平台环境，所以它有跨平台的能力，比如：浏览器平台、Weex、Node 等。</li><li>提高开发速度<br>无需手动操作DOM：只需要写好View-Model的代码逻辑，框架会根据虚拟DOM和数据双向绑定，帮我们更新视图；</li></ul><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>简单来说，diff算法有以下过程</p><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心diff)</li><li>递归比较子节点</li></ul><p>正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -&gt; O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h3 id="Vue2的核心Diff算法"><a href="#Vue2的核心Diff算法" class="headerlink" title="Vue2的核心Diff算法"></a>Vue2的核心Diff算法</h3><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作，直到某一个列表的节点全部遍历过，对比停止。但这比较的过程是全量diff，也就是每个节点都会彼此比较。当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。但其中很显然的是，有些节点中的内容是不会发生改变的，那我们对其进行比较就肯定消耗了时间。</p><h3 id="Vue3的核心Diff算法"><a href="#Vue3的核心Diff算法" class="headerlink" title="Vue3的核心Diff算法"></a>Vue3的核心Diff算法</h3><p>Vue3.x的核心Diff算法采用了静态标记 + 非全量 Diff的方法，在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。那么之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。同时使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作</p><p><img src="https://zyhxwing.gitee.io/images/Vue/1373_0.png" alt="Vue3的Diff算法"></p><p><strong>Vue3的Diff算法</strong></p><p>基于最长递增子序列进行移动/添加/删除</p><h3 id="虚拟DOM中key的作用"><a href="#虚拟DOM中key的作用" class="headerlink" title="虚拟DOM中key的作用"></a>虚拟DOM中key的作用</h3><p>简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。<br><strong>「key的作用是尽可能的复用 DOM 元素」</strong><br>复杂的说：当状态中的数据发生了变化时，vue根据【新数据】生成【新的虚拟DOM】，随后vue进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>旧虚拟DOM中找到了与新虚拟DOM相同的key<br>1.若虚拟DOM中的内容没有变，直接使用之前的真实DOM<br>2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>旧虚拟DOM中未找到与新虚拟DOM相同的key<br>1.根据数据创建新的真实DOM，随后渲染到页面</p><h3 id="用index作为key可能会引发的问题"><a href="#用index作为key可能会引发的问题" class="headerlink" title="用index作为key可能会引发的问题"></a>用index作为key可能会引发的问题</h3><p>若对数据进行：逆序添加/逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果虽然没有问题，但是数据过多的话，会效率过低；<br>如果结构中还包含输入类的DOM，会产生错误DOM更新，界面有问题；<br>注意！如果不存在对数据的逆序操作，仅用于渲染表用于展示，使用index作为key是没有问题的。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。<br>常用的两个属性include/exclude，允许组件有条件的进行缓存。<br>两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。<br>keep-alive的中还运用了LRU(Least Recently Used)算法。</p><h2 id="Vue组件通信方式"><a href="#Vue组件通信方式" class="headerlink" title="Vue组件通信方式"></a>Vue组件通信方式</h2><p>父子组件通信<br>父-&gt;子props，<br>子-&gt;父 $on、$emit<br>获取父子组件实例 $parent、$children<br>Ref 获取实例的方式调用组件的属性或者方法<br>Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>兄弟组件通信<br>Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue<br>Vuex</p><p>跨级组件通信<br>Vuex<br>localstorage、sessionstorage<br>$attrs、$listeners<br>Provide、inject</p><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="7种路由的钩子函数"><a href="#7种路由的钩子函数" class="headerlink" title="7种路由的钩子函数"></a>7种路由的钩子函数</h3><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。</li></ul><h3 id="active-class与exact-active-class"><a href="#active-class与exact-active-class" class="headerlink" title="active-class与exact-active-class"></a>active-class与exact-active-class</h3><ul><li>active-class<br>active-class 是 vue-router 模块的 router-link 组件的属性，当 router-link 标签被点击时将会应用这个样式。</li></ul><p>有两种使用方式：</p><p>直接在路由 Router 构造函数中配置 linkActiveClass 属性<br>export default new Router({<br>linkActiveClass: ‘active’,<br>})<br>使用这种方式，会在每个 router-link 标签上引用这个样式(当被点击后)，如果您只想在某部分 router-link 上使用，则可以选择第二种。</p><p>单独在 router-link 标签上使用 active-class 属性<br><code>&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;about&lt;/router-link&gt;</code><br>最后，为您选中的链接设置样式：</p><ul><li><p>exact-active-class</p><p>配置当链接</p><p>被精确匹配</p><p>的时候应该激活的 class。可以通过以下代码来替代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span> = <span class="string">&quot;&#123; path: &#x27;/route1&#x27;&#125;&quot;</span> <span class="attr">exact-active-class</span> = <span class="string">&quot;_active&quot;</span>&gt;</span>Router Link 1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span> = <span class="string">&quot;&#123; path: &#x27;/route2&#x27;&#125;&quot;</span> <span class="attr">tag</span> = <span class="string">&quot;span&quot;</span>&gt;</span>Router Link 2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>router-link 默认情况下的路由是模糊匹配，例如当前路径是 /article/1 那么也会激活 ，所以当设置 exact-active-class 以后，这个 router-link 只有在当前路由被全包含匹配时才会被激活 exact-active-class 中的 class</p></li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>路由懒加载的主要原理就是原本的Vue模块是全部导入在一起的打包文件，运行后用户查看相关模块显示的内容时<br>会将整个打包的文件引入而后在其中查找对应的模块然后才将其呈现给用户。这样会使得在打包文件中查找对应模块时<br>在浏览器中可能会出现短暂的空白页，从而降低用户体验。<br>而路由懒加载是将各个模块分开打包，在用户查看下相关模块内容时就直接引入相关模块的打包文件然后进行显示，从而有效的解决了浏览器可能出现短暂时间空白页的情况。</p><p>原先的加载方式是先加载子组件，然后将子组件命名为Home，最后再将Home赋给Vue的component。这样就导致子组件的提前加载。 接下来，实现子组件懒加载，则通过将子组件加载语句封装到一个function中，将function赋给component，这种实现了路由懒加载</p><h3 id="路由跳转传值"><a href="#路由跳转传值" class="headerlink" title="路由跳转传值"></a>路由跳转传值</h3><p> 1.query 跳转路由可以用name和path来指定路径 ，不需要配置 ， 地址栏显示参数<br> 2.params 跳转路由只能用name，需要提前配置动态路由 ：ids ，地址栏不显示参数</p><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><p><code>$router</code>为VueRouter实例，想要导航到不同URL，则使用<code>$router.push</code>方法<br><code>$route</code>为当前router跳转对象，里面可以获取name、path、query、params等</p><h3 id="vue中的路由模式-hash和history"><a href="#vue中的路由模式-hash和history" class="headerlink" title="vue中的路由模式 hash和history"></a>vue中的路由模式 hash和history</h3><p>1.hash带#，history没有，更美观点<br>2.history相对比较新，只能兼容ie10，hash能兼容ie8<br>3.两个原理差不多都是通过事件监听，一个是onhashchange（）查找对应的路由规则，另一个onpopstate（）监听URL变化<br>4.hash值在改变的时候，会增加访问历史的记录，可以通过浏览器的操作控制hash的切换；而history里面的pushState（）和replaceState（）会直接替换历史记录，此时需要开发者手动触发页面跳转<br>5.通过URL向后端发起HTTP请求时<br>     1：hash 模式下，仅hash符号之前的内容会被包含在请求中，如 <a href="http://www.abc.com/">http://www.abc.com</a> , 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误。<br>     2：history模式下，前端的URL必须和实际向后端发起请求的URL一致。如htttp://<a href="http://www.abc.com/book/id">www.abc.com/book/id</a> 。如果后端缺少对/book/id 的路由处理，将返回404错误</p><h2 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h2><p>Vue除了核心功能默认内置的指令 ，Vue 也允许注册自定义指令。<br>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</p><p><a href="https://blog.csdn.net/qq_44182284/article/details/111309028">添加自定义指令的两种方式</a></p><p>全局指令： 通过 Vue.directive() 函数注册一个全局的指令。<br>局部指令：通过组件的 directives 属性，对该组件添加一个局部的指令。</p><h2 id="Vue-set-改变数组和对象中的属性"><a href="#Vue-set-改变数组和对象中的属性" class="headerlink" title="Vue.set 改变数组和对象中的属性"></a>Vue.set 改变数组和对象中的属性</h2><p>在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；<br>解决办法：<br>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上</p><p>vm.$set(obj, key, val) 做了什么？<br>由于 Vue 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了vm.set，它是Vue.set的别名。vm.set 用于向响应式对象添加一个新的 property，并确保这个新的 property 同样是响应式的，并触发视图更新。</p><p>为对象添加一个新的响应式数据：调用 defineReactive 方法为对象增加响应式数据，然后执行 dep.notify 进行依赖通知，更新视图<br>为数组添加一个新的响应式数据：通过 splice 方法实现</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件数据之间的共享；Vuex集中管理共享的数据，易于开发和后期维护；能够高效的实现组件之间的数据共享，提高开发效率；存储在Vuex的数据是响应式的，能够实时保持页面和数据的同步；<br>Vuex重要核心属性包括：state,mutations,action,getters,modules.</p><ul><li>state<br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li><li>mutations<br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。</li><li>action<br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li><li>getters<br>类似vue的计算属性，主要用来过滤一些数据。</li><li>modules<br>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</li></ul><h3 id="Vux刷新会消失吗"><a href="#Vux刷新会消失吗" class="headerlink" title="Vux刷新会消失吗"></a>Vux刷新会消失吗</h3><p><strong>会。</strong>vue项目中使用vuex仓储管理保存一些信息的时候，当刷新页面，这些保存在store中的信息就会丢失。</p><p>因为js被加载后是在内存中执行的，js被加载后，其实就是将js代码执行了一遍，在内存中创建了所有js文件中的变量。当需要执行某个方法时其实是在内存中执行该函数。</p><p>当页面进行刷新的时候，之前创建的所有变量内存都会被释放，重新加载js代码，变量重新赋值。所以有些通过用户操作后保存在vuex中的信息就会丢失。</p><ol><li>可以采用其他的存储方法，例如：sessionStorage、localStorage、cookies等。</li><li>也可以采用vuex和sessionStorage 结合的方式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>:sessionStorage.<span class="title function_">getItem</span>(<span class="string">`token`</span>)||<span class="string">``</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">//保存token</span></span><br><span class="line">  <span class="title function_">setToken</span>(<span class="params">state,token</span>)&#123;</span><br><span class="line">    sessionStorage.<span class="title function_">setItem</span>(<span class="string">`token`</span>,token)</span><br><span class="line">    state.<span class="property">token</span>=token;</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="title function_">updateToken</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;setToken&#x27;</span>,value)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。<br>2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p><h2 id="Vue前端权限管理"><a href="#Vue前端权限管理" class="headerlink" title="Vue前端权限管理"></a>Vue前端权限管理</h2><p><a href="https://cloud.tencent.com/developer/article/1794300">前端权限管理</a></p><p>vue前端登录流程</p><ol><li>用户输入账号密码进行登录，登录完拿到token，将token存到cookie和localstorage，之后每次往后端发送请求都通过axios请求拦截器进行拦截，每次请求的时候头部携带token</li><li>在页面初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制。</li><li>在用户登录完之后，在beforeeach 路由钩子函数中设置，每次进行跳转时都先判断缓存内是否有用户的路由表信息，以及跳转的路由是否存在在用户的路由表信息中</li><li>如果没有的话，需要先去获取用户的权限信息，然后筛选有权限访问的路由，最后根据roles权限利用addRoutes方法动态添加该用户可访问的路由表</li></ol><h2 id="Vue3与Vue2的区别"><a href="#Vue3与Vue2的区别" class="headerlink" title="Vue3与Vue2的区别"></a>Vue3与Vue2的区别</h2><p><a href="https://cloud.tencent.com/developer/article/1794328">区别</a></p><p><code>Vue3</code>的新特性，如下：</p><ul><li><p>速度更快: </p><p> vue3相比vue2</p><ul><li>重写了虚拟<code>Dom</code>实现</li><li>编译模板的优化</li><li>更高效的组件初始化</li><li><code>undate</code>性能提高1.3~2倍</li><li><code>SSR</code>速度提高了2~3倍</li></ul></li><li><p>体积减少:</p><p>通过<code>webpack</code>的<code>tree-shaking</code>功能，可以将无用模块“剪辑”，仅打包需要的能够<code>tree-shaking</code>，有两大好处：</p><ul><li>对开发人员，能够对<code>vue</code>实现更多其他的功能，而不必担忧整体体积过大</li><li>对使用者，打包出来的包体积变小了</li></ul><p><code>vue</code>可以开发出更多其他的功能，而不必担忧<code>vue</code>打包出来的整体体积过多</p></li><li><p>更易维护</p><p><strong>compositon Api</strong></p><ul><li>可与现有的<code>Options API</code>一起使用</li><li>灵活的逻辑组合与复用</li><li><code>Vue3</code>模块可以和其他框架搭配使用</li></ul></li><li><p>更接近原生:  可以自定义渲染 API</p></li><li><p>更易使用</p></li></ul><h2 id="Vue前端登录流程"><a href="#Vue前端登录流程" class="headerlink" title="Vue前端登录流程"></a>Vue前端登录流程</h2><p>初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。把用户信息存到Vuex然后再存储到LocalStroage中,然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送post/get请求的时候应该加入token，常用方法再项目utils/service.js中添加全局拦截器，将token的值放入请求头中 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token然后有个跳回登录页面重新登录并且清除本地用户的信息</p><h2 id="搭建一个vue项目"><a href="#搭建一个vue项目" class="headerlink" title="搭建一个vue项目"></a>搭建一个vue项目</h2><ol><li>环境准备nodejs</li><li>全局安装vue-cli脚手架</li><li>用cmd命令创建项目，包括创建文件、选择配置信息、版本</li><li>npm run serve运行项目</li><li>点击项目运行网址就启动了</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2023/03/29/js/"/>
      <url>/2023/03/29/js/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>基本数据类型<br><strong>Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）</strong></li><li>引用数据类型<br><strong>普通对象，数组对象，正则对象，日期对象，Math数学函数对象。</strong></li><li>包装数据类型<br><strong>Number，String，Boolean</strong></li></ul><p><strong>两种数据存储方式：</strong></p><ul><li>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。</li><li>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p><strong>两种数据类型的区别：</strong></p><ul><li>堆比栈空间大，栈比堆运行速度快。</li><li>堆内存是无序存储，可以根据引用直接获取。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li></ul><p>BigInt类型<br>BigInt数据类型提供了一种方法来表示大于2^53-1的整数。BigInt可以表示任意大的整数。</p><p>Symbol类型<br>Symbol 是一种在ES6 中新添加的数据类型，本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值，同时具备隐藏性（for in不能访问）。</p><h2 id="js常见函数"><a href="#js常见函数" class="headerlink" title="js常见函数"></a>js常见函数</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign(target, …sources)</p><p><strong>Object.assign会将source里面的可枚举属性复制到target</strong>，如果和target的已有属性重名，则会覆盖。后续的source会覆盖前面的source的同名属性。Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a,<span class="string">&quot;b&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">value</span>:<span class="number">123</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>);<span class="comment">//123</span></span><br></pre></td></tr></table></figure><p>第一个参数：目标对象<br>第二个参数：需要定义的属性或方法的名字。<br>第三个参数：目标属性所拥有的特性。（descriptor）</p><h3 id="可枚举属性"><a href="#可枚举属性" class="headerlink" title="可枚举属性"></a>可枚举属性</h3><p>可枚举可以理解为是否可以被遍历被列举出来，可枚举性决定了这个属性能否被<strong>for…in</strong>查找遍历到。<br>js中基本包装类型的原型属性是不可枚举的（不可被 for…in… 遍历），比如：Boolean,Number和String三个的原型属性，或是 Boolean,Number值，都是不可枚举的，即是基本类型。基本包装类型还可以像引用类型一样访问它自带的一些方法，但是不能像引用类型那样自定义方法。</p><p>判断属性是否可枚举<br>1.<strong>for…in</strong><br>2.<strong>propertyIsEnumerable( )</strong> 方法返回一个布尔值，表示属性是否可以枚举</p><p>每个对象都有一个propertyIsEnumerable方法。该方法可以确定对象中的指定属性是否可以通过for…in循环枚举，但通过原型链继承的属性除外。如果对象不具有指定的属性，则此方法返回false。</p><h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype用于为某字符串对象新增方法</p><h3 id="forEach、filter、map、some、every、find、findIndex、reduce"><a href="#forEach、filter、map、some、every、find、findIndex、reduce" class="headerlink" title="forEach、filter、map、some、every、find、findIndex、reduce"></a>forEach、filter、map、some、every、find、findIndex、reduce</h3><p>这里有一堆土豆，如果换成代码，可以表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potatos = [&#123; <span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="attr">weight</span>: <span class="number">50</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1002&#x27;</span>, <span class="attr">weight</span>: <span class="number">80</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1003&#x27;</span>, <span class="attr">weight</span>: <span class="number">120</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1004&#x27;</span>, <span class="attr">weight</span>: <span class="number">40</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1005&#x27;</span>, <span class="attr">weight</span>: <span class="number">110</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1006&#x27;</span>, <span class="attr">weight</span>: <span class="number">60</span> &#125;]</span><br></pre></td></tr></table></figure><p>同时把上面的重量（g）记录成一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = [<span class="number">50</span>, <span class="number">80</span>, <span class="number">120</span>, <span class="number">40</span>, <span class="number">110</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure><h4 id="批量操作-foreach"><a href="#批量操作-foreach" class="headerlink" title="批量操作 foreach"></a>批量操作 foreach</h4><p>数组里所有元素的weight增加，修改原数组，无返回值<br>map可实现，但不修改原数组，返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">potatos.<span class="title function_">forEach</span>(<span class="function"><span class="params">potato</span> =&gt;</span> potato.<span class="property">weight</span> += <span class="number">20</span> )</span><br></pre></td></tr></table></figure><h4 id="生成原始数据的特征信息map"><a href="#生成原始数据的特征信息map" class="headerlink" title="生成原始数据的特征信息map"></a>生成原始数据的特征信息map</h4><p>map最适合做的事是映射，生成原始数据的特征信息的map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = potatos.<span class="title function_">map</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> += <span class="number">20</span> &#125;)</span><br><span class="line"><span class="comment">//[ 70, 100, 140, 60, 130, 80 ]</span></span><br></pre></td></tr></table></figure><h4 id="筛选过滤filter"><a href="#筛选过滤filter" class="headerlink" title="筛选过滤filter"></a>筛选过滤filter</h4><p>filter是滤波的意思 从名字上看，就知道筛选过滤这样的活是filter<br>返回一个新的对象数组，并不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigOnes = potatos.<span class="title function_">filter</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//[ &#123; id: &#x27;1003&#x27;, weight: 120 &#125;, &#123; id: &#x27;1005&#x27;, weight: 110 &#125; ]</span></span><br></pre></td></tr></table></figure><h4 id="判断数组中有没有符合条件的时候some"><a href="#判断数组中有没有符合条件的时候some" class="headerlink" title="判断数组中有没有符合条件的时候some"></a>判断数组中有没有符合条件的时候some</h4><p>当只需要判断数组中有没有符合条件的时候（一个就行） 就需要我们的some方法登场了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasbig = potatos.<span class="title function_">some</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们的some小伙计，去土豆存放的仓库进行寻找，只要找到一个符合条件的，就回来报告true 所以并不会全部遍历，不做多余的活（性能优良）</p><h4 id="判断数组元素是否全符合every"><a href="#判断数组元素是否全符合every" class="headerlink" title="判断数组元素是否全符合every"></a>判断数组元素是否全符合every</h4><p>every对每一个元素执行一个callback，直到它找到一个使 callback 返回 false的元素（没那么大的土豆），就返回false，直到遍历完成也没有返回false的话，就返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allbig = potatos.<span class="title function_">every</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="寻找数组元素中一个符合的find"><a href="#寻找数组元素中一个符合的find" class="headerlink" title="寻找数组元素中一个符合的find"></a>寻找数组元素中一个符合的find</h4><p>来了一个顾客，想要一个大土豆 find自告奋勇，我去找给他</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> big = potatos.<span class="title function_">find</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//&#123; id: &#x27;1003&#x27;, weight: 120 &#125;</span></span><br></pre></td></tr></table></figure><p>find和some很类似，都是寻找符合条件的，有一个就可以 不过some进去搜罗了一圈回来报了个“有”（true），而find则把那个土豆抱了出来（返回第一个符合条件的对象）</p><h4 id="当需要知道所需元素的索引findIndex"><a href="#当需要知道所需元素的索引findIndex" class="headerlink" title="当需要知道所需元素的索引findIndex"></a>当需要知道所需元素的索引findIndex</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = potatos.<span class="title function_">findIndex</span>(<span class="function"><span class="params">potato</span>=&gt;</span>&#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>当需要知道所需元素的索引，就可以用findIndex，findIndex返回第一个符合条件的索引号</p><h4 id="递归累加reduce"><a href="#递归累加reduce" class="headerlink" title="递归累加reduce"></a>递归累加reduce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = weight.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, w</span>) =&gt;</span> &#123; <span class="keyword">return</span> w + sum &#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//460</span></span><br><span class="line"><span class="comment">//并不会改变原表格</span></span><br></pre></td></tr></table></figure><p>reduce()方法接收一个回调函数作为第一个参数，回调函数又接受四个参数，分别是；<br>1、previousValue =&gt;初始值或上一次回调函数叠加的值；<br>2、currentValue =&gt; 本次回调（循环）将要执行的值；<br>3、index=&gt;“currentValue”的索引值；<br>4、arr =&gt; 数组本身；<br>reduce()方法返回的是最后一次调用回调函数的返回值；能够实现递归累加</p><h3 id="常见数据类型检测的方式"><a href="#常见数据类型检测的方式" class="headerlink" title="常见数据类型检测的方式"></a>常见数据类型检测的方式</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>其中数组、对象、null都会被判断为Object，其他判断都正确</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>只能判断引用数据类型,不能判断基本数据类型</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了</p><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><p>无论是Array,还是Date，所有数据类型。都是从对象衍生而来的。本质上，Array和Date还有Function啥的他们就是对象。虽然他们都被称为对象，对象也是有很多类型的。比如Date,他就是时间对象‘ [object Date] ’, Array,他就是数组对象‘[object Array]’等等。简而言之，js中所有的数据类型，都只是对象的一种类型。所以，js中有一句话叫，万物皆对象。而<strong>Object.prototype.toString() 这个函数作用就是，返回当前调用者的对象类型。</strong></p><p>因为Object.prototype.toString()返回的是调用者的类型。不论你toString()本身的入参写的是什么，在Object.prototype.toString()中，他的调用者永远都是Object.prototype；所以，在不加call()情况下，我们的出来的结果永远都是 ‘[object Object]’</p><h4 id="isNaN-检测数据是否是数字"><a href="#isNaN-检测数据是否是数字" class="headerlink" title="isNaN 检测数据是否是数字"></a>isNaN 检测数据是否是数字</h4><h4 id="Array-isArray-检测数据是否是数组"><a href="#Array-isArray-检测数据是否是数组" class="headerlink" title="Array.isArray()检测数据是否是数组"></a>Array.isArray()检测数据是否是数组</h4><h3 id="slice、splice、split"><a href="#slice、splice、split" class="headerlink" title="slice、splice、split"></a>slice、splice、split</h3><h4 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="slice(start,[end])"></a>slice(start,[end])</h4><p>slice(start,[end])方法：该方法是对数组进行部分截取，该方法返回一个新数组<br>参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1（可选）。<br>包含了源函数从start到 end 所指定的元素，但是不包括end元素，比如a.slice(0,3)；<br>如果出现负数就把负数与长度相加后再划分。<br>slice中的负数的绝对值若大于数组长度就会显示所有数组<br>若参数只有一个，并且参数大于length，则为空。<br>如果结束位置小于起始位置，则返回空数组<br>返回的个数是end-start的个数<br>不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">/*console.log(arr.slice(3))//[4,5,6] 从下标为0的到3，截取3之后的数</span></span><br><span class="line"><span class="comment">console.log(arr.slice(0,3))//[1,2,3] 从下标为0的地方截取到下标为3之前的数</span></span><br><span class="line"><span class="comment">console.log(arr.slice(0,-2))//[1,2,3,4]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-4,4))//[3,4]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-7))//[1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-3,-3))// []</span></span><br><span class="line"><span class="comment">console.log(arr.slice(8))//[]*/</span></span><br><span class="line"><span class="comment">// 个人总结：slice的参数如果是正数就从左往右数，如果是负数的话就从右往左边数，</span></span><br><span class="line"><span class="comment">// 截取的数组与数的方向一致，如果是2个参数则截取的是数的交集，没有交集则返回空数组</span></span><br><span class="line"><span class="comment">// ps：slice也可以切割字符串，用法和数组一样，但要注意空格也算字符</span></span><br></pre></td></tr></table></figure><h4 id="splice-start-deletecount-item"><a href="#splice-start-deletecount-item" class="headerlink" title="splice(start,deletecount,item)"></a>splice(start,deletecount,item)</h4><p>start：起始位置<br>deletecount：删除位数<br>item：替换的item<br>返回值为被删除的字符串<br>如果有额外的参数，那么item会插入到被移除元素的位置上。<br>splice:移除，splice方法从array中移除一个或多个数组，并用新的item替换它们。<br>举一个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//[&#x27;a&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//[&#x27;b&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//console.log(&quot;被删除的为：&quot;,a.splice(1, 1, 8, 9)); //被删除的为：2</span></span><br><span class="line"><span class="comment">// console.log(&quot;a数组元素：&quot;,a); //1,8,9,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&quot;被删除的为：&quot;, a.splice(0, 2)); //被删除的为：1,2</span></span><br><span class="line"><span class="comment">// console.log(&quot;a数组元素：&quot;, a) //3,4,5,6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被删除的为：&quot;</span>, a.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)) <span class="comment">//插入 第二个数为0，表示删除0个  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a数组元素：&quot;</span>, a) <span class="comment">//1,2,2,2,3,4,5,6</span></span><br></pre></td></tr></table></figure><h4 id="split-字符串"><a href="#split-字符串" class="headerlink" title="split(字符串)"></a>split(字符串)</h4><p>string.split(separator,limit)：split方法把这个string分割成片段来创建一个字符串数组。<br>可选参数limit可以限制被分割的片段数量。<br>separator参数可以是一个字符串或一个正则表达式。<br>如果separator是一个空字符，会返回一个单字符的数组，不会改变原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;0123456&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="comment">//b=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]</span></span><br></pre></td></tr></table></figure><p>注意：String.split() 执行的操作与 Array.join 执行的操作是相反的。</p><h3 id="for-in、Object-keys和for-of"><a href="#for-in、Object-keys和for-of" class="headerlink" title="for in、Object.keys和for-of"></a>for in、Object.keys和for-of</h3><p><strong>for-in</strong><br>for … in是为遍历对象属性而构建的，<br>主要用于遍历对象的<strong>可枚举属性</strong>，包括自有属性、继承自原型的属性</p><p><strong>for-of</strong><br>es6 中添加的循环遍历语法；<br>支持遍历数组，类数组对象（DOM NodeList），字符串，Map 对象，Set 对象；<br>不支持遍历对象； 遍历后输出的结果为数组元素的值</p><p><strong>Object.keys()</strong><br>对数组的遍历顺序和 for in 一致<br>此方法返回一个数组，元素均为对象自有可枚举的属性<br>Object.keys主要用于遍历对象自有的可枚举属性，不包括继承自原型的属性和不可枚举的属性</p><p><strong>Object.getOwnProperty</strong><br>此方法用于返回对象的自有属性，包括可枚举和不可枚举的属性</p><h2 id="var、function变量、函数提升"><a href="#var、function变量、函数提升" class="headerlink" title="var、function变量、函数提升"></a>var、function变量、函数提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数内声明提升，所以上面的代码实际上是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;    <span class="comment">//变量声明提升到函数顶部</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    scope = <span class="string">&#x27;local&#x27;</span>;    <span class="comment">//变量初始化依然保留在原来的位置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是undefined.第二个console.log(scope)语句之前，scope已经完成赋值为’local’，所以输出的结果是local。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式为变量声明，变量声明提升优先级较低</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数声明，函数声明提升优先级更高</span></span><br><span class="line"><span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure><p>让我们来分析一下，这个例子涉及到了变量声明提升和函数声明提升。正如前面说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部。而函数表达式var getName = function(){}则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。<strong>需要注意的是，函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量</strong>。因此上面的函数可以转换成下面的样子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line">getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getName</span>();    <span class="comment">// 最终输出：2</span></span><br></pre></td></tr></table></figure><p>所以最终的输出结果是：2。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2。</p><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 id="parseInt方法"><a href="#parseInt方法" class="headerlink" title="parseInt方法"></a>parseInt方法</h3><h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><h3 id="异步Promise、Generator和Async"><a href="#异步Promise、Generator和Async" class="headerlink" title="异步Promise、Generator和Async"></a>异步Promise、Generator和Async</h3><h3 id="数组遍历方法for-in、Object-keys"><a href="#数组遍历方法for-in、Object-keys" class="headerlink" title="数组遍历方法for in、Object.keys()"></a>数组遍历方法for in、Object.keys()</h3><h3 id="Symbol-bigInt"><a href="#Symbol-bigInt" class="headerlink" title="Symbol\bigInt"></a>Symbol\bigInt</h3><h3 id="数据结构Set和Map"><a href="#数据结构Set和Map" class="headerlink" title="数据结构Set和Map"></a>数据结构Set和Map</h3><h3 id="class定义类"><a href="#class定义类" class="headerlink" title="class定义类"></a>class定义类</h3><h3 id="reflect对象"><a href="#reflect对象" class="headerlink" title="reflect对象"></a>reflect对象</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reflect.defineProperty会返回false来代表此次操作失败</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;鲨鱼辣椒&#x27;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>) <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&#125;)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;鲨鱼辣椒&#x27;</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 鲨鱼辣椒</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">// 鲨鱼辣椒</span></span><br></pre></td></tr></table></figure><p>Proxy可以最大限度的弥补Object.defineProperty带来的缺点，而Proxy也不仅仅只能代理对象，还可以代理数组等其它对象。代理可以捕获13种不同的操作，而每种操作都会有一个所对应的ReflectApi，这就使Proxy对象可以方便的调用对应的Reflect方法来完成默认行为。我们前面已经对Proxy与Reflect进行了讲解，现在就让它们结合起来吧</p><h3 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h3><p>var ——ES5 变量声明方式变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</p><p>let——ES6变量声明方式<br>在变量为声明前直接使用会报错<br>作用域——let为块作用域——通常let比var 范围要小<br>let禁止重复声明变量，否则会报错；var可以重复声明</p><p>const——ES6变量声明方式</p><ol><li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值</li><li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</li></ol><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><p>暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错 因为本区域有tmp声明变量</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// 绑定if这个块级的作用域 不能出现tmp变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p><strong>概念</strong>：多个作用域对象连续引用形成的链式结构。</p><p><strong>使用方面解释</strong>：当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，如果在全局作用域里仍然找不到该变量，它就会直接报错。</p><p><strong>存储方面解释</strong>：作用域链在JS内部中是以数组的形式存储的，数组的第一个索引对应的是函数本身的执行期上下文，也就是当前执行的代码所在环境的变量对象，下一个索引对应的空间存储的是该对象的外部执行环境，依次类推，一直到全局执行环境</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">200</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//100</span></span><br><span class="line"><span class="comment">// fun函数局部作用域中没有变量a，于是从它的上一级，也就是全局作用域中找，</span></span><br><span class="line"><span class="comment">//在全局中a被赋值为100，于是输出100</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)<span class="comment">//200 fun函数局部作用域中有变量b，并且它被赋值为了200，输出200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">f</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">   (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">f</span>()   <span class="comment">//10，而不是20; 函数的作用域是在函数定义的时候就被决定了，与函数在哪里被调用无关</span></span><br><span class="line">   &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fun)</span><br></pre></td></tr></table></figure><p>由于变量的查找是沿着作用域链来实现的，所以也称作用域链为变量查找的机制。是不是很好理解，这里再来补充一点作用域的作用</p><ul><li>作用域最为重要的一点是安全。变量只能在特定的区域内才能被访问，外部环境不能访问内部环境的任何变量和函数，即可以向上搜索，但不可以向下搜索， 有了作用域我们就可以避免在程序其它位置意外对某个变量做出修改导致程序发生事故。</li><li>作用域能够减轻命名的压力。我们可以在不同的作用域内定义相同的变量名，并且这些变量名不会产生冲突。。</li></ul><h4 id="为什么let在编译后实际还是var？"><a href="#为什么let在编译后实际还是var？" class="headerlink" title="为什么let在编译后实际还是var？"></a>为什么let在编译后实际还是var？</h4><p><strong>原因：</strong></p><ol><li>let 和 const 是 ES6 新增的变量申明关键字， 和 var 的主要区别在于作用域的不同，var 支持全局作用域和函数作用域，而 let 和 const 是块作用域。Babel 使用 babel-plugin-transform-block-scoping 插件完成 let 到 var 的转换，本质是块作用域到函数作用域或全局作用域的转换。</li><li>Babel 在生成 AST 之后，定义了一个访问者（visitor），用于遍历 AST 的过程中，根据语法规则生成作用域对象(Scope)，该对象中定义了该作用域下绑定的变量，这些变量是否被引用以及每个引用具体的路径。这些信息是后续修改作用域以及变量更换绑定的基础。</li><li>let 直接变为 var 很容易导致语义变化，需要结合作用域和上下文来进行判断，如果变成 var 后，和同层作用域的变量名称发生冲突，可以修改名称解决。如果 let 被内层作用域的方法引用，则需要修改代码，形成闭包。</li><li>babel-plugin-transform-block-scoping 插件是 Babel 中负责块级作用域转换的插件，实现了收集作用域下变量，判断是否存在闭包，let 节点修改等功能。我们在自己编写插件的时候，最好能多看几个 Babel 的原生插件，不仅可以了解 Babel 编译的原理，还可以学一些 AST 操作的方法。</li></ol><p><strong>如何变化</strong></p><ol><li>let 处于全局作用域，那么 let 直接变成 var。</li><li>let 处于块作用域，那就要判断该变量升级至上级的函数作用域或者全局作用域后，是否会与同一作用域的变量发生重名现象，如果重名，那就换个变量名。同时修改所有引用这个变量的代码。</li><li>let 处于循环语句中，形成类似闭包的效果，此时需要将循环内部的方法转换为立即执行函数的写法，利用闭包的特性保存循环次数。</li></ol><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头=&gt;来定义函数。</p><p>关于箭头函数的参数：① 如果箭头函数没有参数，直接写一个空括号即可。② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。</p><p>① 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p><p>② 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写</p><p>③ 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），可以给这条语句前面加一个void关键字</p><p>区别：</p><ul><li>语法更加简洁、清晰。箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</li><li>箭头函数不会创建自己的this。箭头函数没有自己的this，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。</li><li>箭头函数继承而来的this指向永远不变。call()/.apply()/.bind()无法改变箭头函数中this的指向.call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。</li><li>箭头函数不能作为构造函数使用。因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，</li><li>箭头函数没有自己的arguments</li><li>箭头函数没有原型prototype</li><li>箭头函数不能用作Generator函数，不能使用yeild关键字</li></ul><h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><ol><li>创建一个空对象</li><li>this指向这个对象</li><li>执行构造函数的语句</li><li>返回该对象</li></ol><h2 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>将父类的实例作为子类的原型</p><p>优点</p><ul><li>父类方法可以复用<br>缺点</li><li>父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</li><li>子类型实例不能给父类型构造函数传参</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">isShow</span> = <span class="literal">true</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">info</span> = &#123;</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getInfo</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">info</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">isShow</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Child1</span> = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property">info</span>.<span class="property">gender</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="title function_">getInfo</span>();  <span class="comment">// &#123;name: &quot;yhd&quot;, age: 18, gender: &quot;男&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child2.<span class="title function_">getInfo</span>();  <span class="comment">// &#123;name: &quot;yhd&quot;, age: 18, gender: &quot;男&quot;&#125;</span></span><br><span class="line">child2.<span class="property">isShow</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">isShow</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h3><ul><li>先定义一个父构造函数(this指向为window)</li><li>再定义一个子构造函数(this指向为new出的实例化对象)</li><li>子构造函数通过call()改变父的this指向继承父构造函数属性</li></ul><p>优点</p><ul><li><p>可以在子类构造函数中向父类传参数</p></li><li><p>父类的引用属性不会被共享<br>缺点</p></li><li><p>不能继承原型属性，无法实现函数复用，所有方法都只能放在构造函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">info</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child1.<span class="property">info</span>.<span class="property">gender</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">info</span>); <span class="comment">// &#123;name: &quot;yhd&quot;, age: 19, gender: &quot;男&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">info</span>); <span class="comment">// &#123;name: &quot;yhd&quot;, age: 19&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承综合了<strong>原型链继承</strong>和<strong>盗用构造函数继承</strong>(构造函数继承)，将两者的优点结合了起来，</p><p>基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="comment">// 继承父类属性</span></span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类方法</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yhd&quot;</span>, <span class="number">19</span>);</span><br><span class="line">child1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;pink&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span></span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 19</span></span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;yhd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;wxb&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">colors</span>);  <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]</span></span><br><span class="line">child2.<span class="title function_">sayAge</span>(); <span class="comment">// 30</span></span><br><span class="line">child2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;wxb&quot;</span></span><br></pre></td></tr></table></figure><p>上面例子中，Parent构造函数定义了name，colors两个属性，接着又在他的原型上添加了个sayName()方法。Child构造函数内部调用了Parent构造函数，同时传入了name参数，同时Child.prototype也被赋值为Parent实例，然后又在他的原型上添加了个sayAge()方法。这样就可以创建 child1，child2两个实例，让这两个实例都有自己的属性，包括colors，同时还共享了父类的sayName方法</p><p>优点</p><ul><li>父类的方法可以复用</li><li>可以在Child构造函数中向Parent构造函数中传参</li><li>父类构造函数中的引用属性不会被共享</li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>对参数对象的一种浅复制</p><p>优点：</p><ul><li>父类方法可复用<br>缺点：</li><li>父类的引用会被所有子类所共享</li><li>子类实例不能向父类传参</li><li>ES5的Object.create()方法在只有第一个参数时，与这里的objectCopy()方法效果相同</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的objectCopy可以改用 ES5 里面的 Object.create 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;rose&quot;</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;wxb&quot;</span>;</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// wxb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;gsr&quot;</span>;</span><br><span class="line">person2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;gsr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;lily&quot;, &quot;kobe&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p><p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p><p><strong>设计模式：装饰器模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">objectCopy</span>(original);</span><br><span class="line">  clone.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">     <span class="attr">friends</span>: [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>);</span><br><span class="line">person1.<span class="title function_">getName</span>(); <span class="comment">// yhd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;lily&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>寄生式继承+组合继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">objectCopy</span>(parent.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//上一句可以用Object.create来代替</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = child; <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;lily&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yhd&quot;</span>, <span class="number">23</span>);</span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// yhd</span></span><br><span class="line">child1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;, &quot;jack&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yl&quot;</span>, <span class="number">22</span>)</span><br><span class="line">child2.<span class="title function_">sayAge</span>(); <span class="comment">// 22</span></span><br><span class="line">child2.<span class="title function_">sayName</span>(); <span class="comment">// yl</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;]</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>只调用一次父类构造函数</li><li>Child可以向Parent传参</li><li>父类方法可以复用</li><li>父类的引用属性不会被共享</li></ul><p>寄生式组合继承可以算是引用类型继承的最佳模式</p><h3 id="ES6-的-extends-关键字"><a href="#ES6-的-extends-关键字" class="headerlink" title="ES6 的 extends 关键字"></a>ES6 的 extends 关键字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> juiceice = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;juiceice&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">juiceice.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>对象里的属性分为两种：数据属性 和 访问器属性。首先我们看看数据属性。</p><p><strong>数据属性</strong></p><ol><li>[[<strong>Configurable</strong>]]：翻译：adj. 可配置的；结构的 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特 性都是 true，如前面的例子所示。</li><li>[[<strong>Enumerable</strong>]]：翻译：adj. 可列举的；可点数的 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true，如前面的例子所示。</li><li>[[<strong>Writable</strong>]]：翻译：adj. 可写的，能写成文的 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的 这个特性都是 true，如前面的例子所示。</li><li>[[<strong>Value</strong>]]：翻译：值 包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性 的默认值为 undefined</li></ol><p><strong>访问器属性</strong></p><ol><li>[[<strong>Configurable</strong>]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li><li>[[<strong>Enumerable</strong>]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。</li><li>[[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为 undefined。</li><li>[[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为 undefined。</li></ol><h2 id="js事件流"><a href="#js事件流" class="headerlink" title="js事件流"></a>js事件流</h2><p>事件流一共由三个阶段分别是<br>1.捕获阶段<br>2.目标阶段<br>3.冒泡阶段</p><p>通俗一点来说就是一个事件被触发时，浏览器会自动从用户操作标签外的最上级标签逐渐向里检查是否有相同事件，如果有则触发，如果没有则继续向下检查直到用户操作的标签，这过程称为捕获，此时浏览器会继续由用户操作标签继续向上级标签检查，如果有相同事件则触发，如果没有则继续向上检查直到最上级元素为止，此过程称为冒泡。</p><p>从外向内找监听函数，叫做事件捕捉<br>从内向外找监听函数，叫做事件冒泡</p><p><strong>取消冒泡 e.stopPropagation()</strong><br>捕获是不可取消的，但是冒泡可以取消。所有冒泡皆可取消，默认动作有的可以取消有的不能取消。e.stopPropagation() 可以中断冒泡，浏览器不再向上走了。</p><p>事件委托<br>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，click事件的监听函数定义在节点，但是实际上，它处理的是子节点的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p><p><strong>优点</strong><br>省监听数（内存）<br>可以监听动态元素</p><h2 id="js的事件循环"><a href="#js的事件循环" class="headerlink" title="js的事件循环"></a>js的事件循环</h2><p><img src="https://zyhxwing.gitee.io/images/JavaScript/1363_1.png" alt="js事件循环"></p><p><strong>js事件循环</strong></p><p>S是单线程的，但是我们在写代码的时候，会有同步执行的代码和异步执行的代码。EventLoop就是一种解决异步回调的一种机制。具体的解决办法就是使用一个执行栈和事件队列，事件队列又分为宏任务队列和微任务队列。简单的来讲，就是把代码从上到下，会把同步任务压入到执行栈，遇到异步的任务，根据异步任务的类型，放入不同的事件队列，交给其它线程进行处理。如果执行栈空的话，就从事件队列当中取出结果，放入到执行栈中执行并执行。Event Loop 的每一次循环称为一个tick，具体是先拿出一个宏任务，然后检查它里面的微任务，如果有的话，就执行所有的微任务，结束之后，进行一次渲染。再拿出一个宏任务，按照刚刚的过程继续进行</p><h3 id="宏任务MacroTask"><a href="#宏任务MacroTask" class="headerlink" title="宏任务MacroTask"></a>宏任务MacroTask</h3><p>script代码、settimeout、promise、async、setInterval、ajax、dom监听、UI Rendering</p><h3 id="微任务MicroTask"><a href="#微任务MicroTask" class="headerlink" title="微任务MicroTask"></a>微任务MicroTask</h3><p>promise的回调函数（then、catch、finally）、await、queueMicrotask、MutationObserver的Api</p><h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h3><p>与此同时，针对于vue的mvvn框架，在修改数据之后，视图并不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>Vue.nextTick将回调函数放到微任务或者宏任务当中以延迟它地执行顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;changed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// 并不会得到&#x27;changed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//可以得到&#x27;changed&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="settimeout倒计时为什么会出现误差"><a href="#settimeout倒计时为什么会出现误差" class="headerlink" title="settimeout倒计时为什么会出现误差"></a>settimeout倒计时为什么会出现误差</h3><p>setTimeout作为异步任务，在实现倒计时功能的时候，除了执行我们功能的实现代码，还会有主线程对任务队列的读取及执行等过程，这些过程也需要耗费一些时间，所以会因为event loop的机制出现些许误差。</p><h3 id="为什么使用setTimeout实现倒计时，而不是setInterval"><a href="#为什么使用setTimeout实现倒计时，而不是setInterval" class="headerlink" title="为什么使用setTimeout实现倒计时，而不是setInterval?"></a>为什么使用setTimeout实现倒计时，而不是setInterval?</h3><p>setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。<br>为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p><ul><li>监视 DOM 变动的接口<br>当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。</li><li>类似于事件，但是异步触发<br>添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver 是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br></pre></td></tr></table></figure><h3 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h3><p>queueMicrotask()的作用是创建一个微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">queueMicrotask</span>(fn)</span><br><span class="line"><span class="comment">//等同于Promise.resolve().then(fn);</span></span><br></pre></td></tr></table></figure><p>效果和使用Promise一样的，都是将任务加入微任务队列<br>待宏任务结束后依次执行</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。requestAnimationFrame(rAF) 需要传入一个回调函数作为参数，同时该回调函数会在浏览器下一次重绘之前执行。</p><p>requestAnimationFrame(rAF) 的回调有两个特征：<br>在重新渲染前调用。<br>很可能在宏任务之后不调用。</p><p>我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。<br>rAF在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个结果是非常不可控的，如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">req</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  i--</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">req</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">req</span>()</span><br><span class="line"><span class="comment">//浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，</span></span><br></pre></td></tr></table></figure><h2 id="js异步方法"><a href="#js异步方法" class="headerlink" title="js异步方法"></a>js异步方法</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>是异步操作最基本的方法，比如AJAX回调，回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用try catch捕获错误，不能之间return。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve和reject方法，then接收到对应的数据，做出相应的处理。Promise不仅能够捕获错误，而且也能很好地解决了回调地狱的问题，缺点是无法取消Promise，错误需要通过回调函数捕获。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>函数是ES6提供的一种异步编程解决方案，Generator函数是一个状态机，封装了多个内部状态，可暂停函数，yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。优点是异步语义清晰，缺点是手动迭代Generator函数很麻烦，实现逻辑优点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> y = <span class="keyword">yield</span> x + <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 7, done: false &#125;</span></span><br><span class="line"><span class="comment">//调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行</span></span><br><span class="line"><span class="comment">// 执行完成会返回一个 Object,</span></span><br><span class="line"><span class="comment">// value 就是执行 yield 后面的值,done 表示函数是否执行完毕</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// 因为最后一行 return y 被执行完成,所以done 为 true</span></span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>是于Promise实现的，async/awt使得异步代码看起来像同步代码，所以优点是使用方法清晰明了，缺点是await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低，代码没有依赖性的话，完全可以使用Promise.all的方式。</p><h2 id="异步网络请求xhr、ajax、fetch与axios"><a href="#异步网络请求xhr、ajax、fetch与axios" class="headerlink" title="异步网络请求xhr、ajax、fetch与axios"></a>异步网络请求xhr、ajax、fetch与axios</h2><p>现代浏览器，最开始与服务器交换数据，都是通过 XMLHttpRequest 对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123; <span class="comment">// model browser</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">ActiveXObject</span>) &#123; <span class="comment">// IE 6 and older</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">&#125;<span class="comment">//创建xhr对象</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>)<span class="comment">//调用xhr.open()函数</span></span><br><span class="line"><span class="comment">//设置Content-Type属性</span></span><br><span class="line">xhr.<span class="title function_">send</span>(data)<span class="comment">//调用xhr.send()函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//监听xhr.onreadStatechange()事件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求正常</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理响应</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求遇到一些问题，处理异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 还处于未准备好的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 通信错误的事件中（例如服务器宕机）</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Caught Exception: &#x27;</span> + e.<span class="property">description</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>不重新加载页面的情况下更新网页<br>在页面已加载后从服务器请求/接收数据<br>在后台向服务器发送数据。<br>缺点：</p><p>使用起来也比较繁琐，需要设置很多值。<br>早期的IE浏览器有自己的实现，这样需要写兼容代码。</p><p>xhr的readyState，状态码<br>0 对象被创建但没有使用open方法<br>1 open方法已经被调用<br>2 send方法已经被调用<br>3 数据接受，response属性已经包含部分数据<br>4 ajax请求完成</p><ol><li><p>jQuery ajax<br>为了更快捷的操作 DOM，并且规避一些浏览器兼容问题，产生了 jQuery 。它里面的 AJAX 请求也兼容了各浏览器，可以有简单易用的方法 $.get, $.post 。简单点说，就是对 XMLHttpRequest 对象的封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: url, </span><br><span class="line">  <span class="attr">data</span>: data,</span><br><span class="line">  <span class="attr">dataType</span>: dataType,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优点：<br>XHR JSONP<br>缺点：<br>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。<br>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。<br>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</p></li><li><p>fetch<br>Fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p></li></ol><p>fetch 是底层API，代替 XHR ，可以轻松处理各种格式，非文本化格式。可以很容易的被其他技术使用，例如 Service Workers 。但是想要很好的使用 fetch ，需要做一些封装处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>优点：跨域的处理</p><p>在配置中，添加mode： ‘no-cors’就可以跨域了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/users.json&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>, </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;no-cors&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* handle response */</span> &#125;);</span><br></pre></td></tr></table></figure><p>缺点：</p><p>fetch 只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理<br>fetch 默认不会带 cookie ，需要添加配置项。<br>fetch 不支持 abort ，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。<br>fetch 没有办法原生监测请求的进度，而 XHR 可以。<br>请注意， fetch 规范与 jQuery.ajax() 主要有三点不同，牢记：</p><p>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject ， 即使该 HTTP 响应的状态码是 404 或 500 。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject 。<br>fetch() 不会接受跨域 cookies ；你也不能使用 fetch() 建立起跨域会话。其他网站的 Set-Cookie 头部字段将会被无视。<br>fetch 不会发送 cookies 。除非你使用了 credentials 的 初始化选项。（自2017年8月25日以后，默认的 credentials 策略变更为 same-origin 。Firefox也在61.0b13版本中，对默认值进行修改）<br>\4. axios<br>axios 是一个基于 promise 的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生 XMLHttpRequest 的封装，只不过它是 Promise 的实现版本，符合最新的ES规范。</p><p>这是官方的并发案例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(),<span class="title function_">getUserPermissions</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span> (<span class="params">acct, perms</span>) &#123;</span><br><span class="line">    <span class="comment">// Both requests are now complete</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure><p>axios是尤雨溪大神推荐使用的,</p><p>优点：</p><p>XMLHttpRequests<br>node.js<br>Promise API<br>JSON<br>XSRF<br>缺点：</p><p>只持现代浏览器</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>javascript和typescript的区别是什么</p><p>区别：<br>1、TypeScript中的数据要求带有明确的类型，JavaScript不要求。<br>2、TypeScript引入了JavaScript中没有的“类”概念。<br>3、TypeScript通过类型注解提供编译时的静态类型检查（ 虽然JavaScript是弱类型语言，但是在将其升级改造引入”类型注解”这一概念后的TypeScript中，类型注解相当于强类型语言中声明了某个变量的类型，以后该变量就必须为此类型，否则ts编译器将报错，并不能正确地编译成js文件。）。</p><h2 id="JS的arugments"><a href="#JS的arugments" class="headerlink" title="JS的arugments"></a>JS的arugments</h2><p>在函数调用的时候，浏览器每次都会传递进两个隐式参数：<br>一个是函数的上下文对象this，另一个则是封装实参的类数组对象arguments。</p><p>1、arguments是一个类数组对象，用来存储实参；具有length、callee等属性；可以用arguments[0]这个形式访问实参；可以转换为真实数组。<br>2、arguments和函数相关联，其只有在函数执行时可用，不能显式创建。<br>3、arguments可以用来遍历参数；通过callee实现递归；也可以模拟函数重载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 可以使用slice来将arguments转换为真实数组</span></span><br><span class="line">    <span class="keyword">var</span> args1 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> args2 = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">// 也可以使用Array.from()方法或者扩展运算符来将arguments转换为真实数组</span></span><br><span class="line">    <span class="keyword">var</span> args3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> args4 = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f5</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JS的原型链"><a href="#JS的原型链" class="headerlink" title="JS的原型链"></a>JS的原型链</h2><p>什么是原型：任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。</p><p>什么是原型链：<strong>原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__中查找，也就是构造函数的显式原型prototype中查找，如果构造函数的显式原型prototype中也没有该属性，因为构造函数的显式原型prototype也是对象，也有__proto__，那么会去它的__proto__指向的另一个显式原型prototype中查找，一直到null，如果没有则返回undefined</p><ul><li>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型)</li><li>所有函数除了有_proto_属性之外还拥有prototype属性（显式原型）</li></ul><h2 id="JS-set、map、weakset、weakmap区别"><a href="#JS-set、map、weakset、weakmap区别" class="headerlink" title="JS set、map、weakset、weakmap区别"></a>JS set、map、weakset、weakmap区别</h2><p>共同点：<br>他们都是构造函数</p><p>不同点：<br>1、weakset、set不允许有重复的数据，set可以存储原始值和对象引用，存储的数据必须是唯一值<br>2、weakset是弱集合，存储的数据只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>3、map表示字典，用键值对的形式存放数据，键和值可以是原始值和对象引用<br>4、weakmap是弱字典，以键值对形式存放，键只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的；所以不容易造成内存泄漏。</p><h2 id="js-垃圾回收机制"><a href="#js-垃圾回收机制" class="headerlink" title="js 垃圾回收机制"></a>js 垃圾回收机制</h2><p>我们知道，程序运行中会有一些垃圾数据不再使用，需要及时释放出去，如果我们没有及时释放，这就是内存泄露。JavaScript 是一门具有自动垃圾收集机制的编程语言，由执行环境负责在代码执行时管理内存。JS 中的垃圾数据都是由垃圾回收（Garbage Collection，缩写为 GC）器自动回收的，不需要手动释放。JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可。</p><p>常见的垃圾回收方法：1）引用计数方法；2）标记清除方法。</p><p><strong>1）引用计数</strong><br>引用计数就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加一，反之解除时就减一，当该对象引用计数为 0 时就会被回收。如果出现循环引用，则一直不会被回收，还是会造成内存泄漏。</p><p>解决办法：及时销毁绑定的事件、使用弱引用 weakMap、weakSet。</p><p><strong>2）标记清除方法。</strong></p><p>V8 中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：<br>标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。<br>清除：将所有垃圾数据清理掉。</p><p><img src="https://zyhxwing.gitee.io/images/JavaScript/1365_1.png" alt="标记清除方法"></p><p><strong>标记清除方法</strong></p><p>垃圾回收算法垃圾回收的实现简单分为以下三个步骤：<br><strong>1）可访问性</strong><br>从 GC Roots 对象出发，遍历 GC Root 中的所有对象：<br>a、可访问对象：通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留。<br>b、不可访问对象：通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），并会对其做上标记，那么这些不可访问的对象就可能被回收。</p><p>GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：全局的 window 对象（位于每个 iframe 中）；文档 DOM 树，可以通过遍历文档到达的所有原生 DOM 节点组成；存放栈上变量。</p><p><strong>2）回收不可访问对象所占据的内存</strong><br>在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p><strong>3）内存整理</strong><br>频繁回收对象后，内存中就会存在大量不连续空间，称为内存碎片。当出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就会出现内存不足的情况，所以最后一步需要整理这些内存碎片。</p><p>在我们的实际开发过程中，如果我们想要让垃圾回收器回收某一对象，就将对象的引用直接设置为 null。但如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 null 时，该对象是不会被回收的，依然存在。</p><h2 id="Cookie、LocalStorage、SessionStorage"><a href="#Cookie、LocalStorage、SessionStorage" class="headerlink" title="Cookie、LocalStorage、SessionStorage"></a>Cookie、LocalStorage、SessionStorage</h2><p><img src="https://zyhxwing.gitee.io/images/JavaScript/1367_1.png" alt="Cookie、LocalStorage、SessionStorage"></p><p><strong>Cookie、LocalStorage、SessionStorage</strong></p><h3 id="cookies属性有哪些"><a href="#cookies属性有哪些" class="headerlink" title="cookies属性有哪些"></a>cookies属性有哪些</h3><ul><li>cookieName=cookieValue 设置 cookie 的名字和值，必填项。</li><li>HttpOnly 只能通过 HTTP 响应报文的 Set-Cookie 来新增或更新 cookie ，客户端无法通过脚本的方式来读写 cookie。</li><li>Expires cookie 的过期时间点</li><li>Max-Age cookie 的有效时间长度</li><li>Path 设置 cookie 的路径作用域</li><li>Domain 设置 cookie 的 domain 作用域。</li><li>Secure 该属性没有值，属性本身存在就代表设置为安全模式。即请求必须为安全连接（HTTPS），cookie 才会被保存下来。HTTP 协议下，cookie 无效。</li><li>SameSite cookie 在跨域时是否应该被发送。</li></ul><h2 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h2><p>闭包是指有权访问另外一个函数作用域中的变量的函数。<br>内部的函数存在外部作用域的引用就会导致闭包。</p><p>闭包中的变量存储的位置是堆内存。</p><p><strong>作用：</strong><br>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化。局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。</p><p><strong>闭包使用场景</strong><br>return一个函数<br>函数作为参数<br>循环赋值<br>防抖节流</p><p><strong>闭包缺点</strong><br>容易导致内存泄漏。闭包会携带包含它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多</p><h2 id="js内存泄漏"><a href="#js内存泄漏" class="headerlink" title="js内存泄漏"></a>js内存泄漏</h2><h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><p>当内存中本应该在垃圾回收周期中清理的对象，因为被另一个对象的无意引用而从根能够保持可访问时，就会发生内存泄漏。将冗余对象保留在内存中会导致应用程序内部使用过多的内存，并可能导致性能下降。</p><h3 id="performance工具"><a href="#performance工具" class="headerlink" title="performance工具"></a>performance工具</h3><ul><li>打开浏览器输入目标网址</li><li>进入开发人员工具面板，选择性能</li><li>开启录制功能，访问具体界面</li><li>执行用户行为，一段时间后停止录制</li><li>分析界面中记录的内存信息</li></ul><h3 id="那该如何判断代码正在泄漏内存呢？"><a href="#那该如何判断代码正在泄漏内存呢？" class="headerlink" title="那该如何判断代码正在泄漏内存呢？"></a>那该如何判断代码正在泄漏内存呢？</h3><ul><li>内存使用检查最快的方法就是<strong>查看浏览器的任务管理器</strong>。 它们提供了当前在浏览器中运行的所有选项卡和进程的概览。在任务管理器中查看每个选项卡的 JavaScript 内存占用情况。如果网站什么都不做，但是 JavaScript 内存使用量却在逐渐增加，那们很有可能发生了内存泄漏。（快捷键 shift+esc）</li><li>timeline时序图记录（控制台 性能 记录 ）</li><li>堆快照查找分离DOM（控制台 内存 堆快照）</li><li>判断是否存在频繁的垃圾回收GC<ul><li>timeline中频繁的上升下降</li><li>任务管理器中数据频繁的增加减少</li></ul></li></ul><h3 id="什么会导致内存泄漏呢"><a href="#什么会导致内存泄漏呢" class="headerlink" title="什么会导致内存泄漏呢"></a>什么会导致内存泄漏呢</h3><ol><li>意外的全局变量：由于使用未声明的变量,而意外的创建了一个全局变量,而使这个变量一直留在内存中无法被回收。<strong>通过使用严格模式“use strict”来避免这一切。在JavaScript文件的开头，它将开启更严格的JavaScript解析模式，从而防止意外的创建全局变量。</strong></li><li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。<strong>修改计时器回调中引用的对象；必要时使用从计时器返回的句柄（定时器的标识符）取消它clearInterval()。</strong></li><li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。要解决此问题，<strong>可以在完成后，删除指向DOM元素的变量。</strong></li><li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。<strong>了解何时创建闭包以及闭包保留了哪些对象；了解闭包的预期寿命和用法（尤其是用作回调时）。</strong></li><li>事件监听器：事件侦听器将防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到：<strong>使用 removeEventListener() 显式删除或者关联的 DOM 元素被移除。</strong></li><li>缓存：如果不断地将内存添加到缓存中，而不删除未使用的对象，并且没有一些限制大小的逻辑，那么缓存可以无限增长。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user_1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Peter&quot;</span>, <span class="attr">id</span>: <span class="number">12345</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> user_2 = &#123; <span class="attr">name</span>: <span class="string">&quot;Mark&quot;</span>, <span class="attr">id</span>: <span class="number">54321</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> mapCache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mapCache.<span class="title function_">has</span>(obj))&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="string">`<span class="subst">$&#123;obj.name&#125;</span> has an id of <span class="subst">$&#123;obj.id&#125;</span>`</span>;</span><br><span class="line">    mapCache.<span class="title function_">set</span>(obj, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [value, <span class="string">&#x27;computed&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [mapCache.<span class="title function_">get</span>(obj), <span class="string">&#x27;cached&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cache</span>(user_1); <span class="comment">// [&#x27;Peter has an id of 12345&#x27;, &#x27;computed&#x27;]</span></span><br><span class="line"><span class="title function_">cache</span>(user_1); <span class="comment">// [&#x27;Peter has an id of 12345&#x27;, &#x27;cached&#x27;]</span></span><br><span class="line"><span class="title function_">cache</span>(user_2); <span class="comment">// [&#x27;Mark has an id of 54321&#x27;, &#x27;computed&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapCache); <span class="comment">// &#123;&#123;…&#125; =&gt; &#x27;Peter has an id of 12345&#x27;, &#123;…&#125; =&gt; &#x27;Mark has an id of 54321&#x27;&#125;</span></span><br><span class="line">user_1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapCache); <span class="comment">// &#123;&#123;…&#125; =&gt; &#x27;Peter has an id of 12345&#x27;, &#123;…&#125; =&gt; &#x27;Mark has an id of 54321&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，缓存仍然保留 user_1 对象。因此，我们需要将那些永远不会被重用的变量从缓存中清除。<strong>可以使用 WeakMap 来解决此问题。</strong>它是一种具有弱键引用的数据结构，仅接受对象作为键。如果我们使用一个对象作为键，并且它是对该对象的唯一引用——相关变量将从缓存中删除并被垃圾收集。在以下示例中，将 user_1 对象清空后，相关变量会在下一次垃圾回收后自动从 WeakMap 中删除。</p><h2 id="TypeScript与JavaScript区别"><a href="#TypeScript与JavaScript区别" class="headerlink" title="TypeScript与JavaScript区别"></a>TypeScript与JavaScript区别</h2><p>区别：</p><ol><li>TypeScript中的数据要求带有明确的类型，JavaScript不要求。</li><li>TypeScript引入了JavaScript中没有的“类”概念。</li><li>TypeScript通过类型注解提供编译时的静态类型检查（ 虽然JavaScript是弱类型语言，但是在将其升级改造引入”类型注解”这一概念后的TypeScript中，类型注解相当于强类型语言中声明了某个变量的类型，以后该变量就必须为此类型，否则ts编译器将报错，并不能正确地编译成js文件）。</li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/1/170965259fb768fd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="深拷贝和浅拷贝"></p><p><strong>深拷贝和浅拷贝</strong></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>浅拷贝：</p><ul><li>Object.assign()</li><li>lodash.clone</li><li>展开运算符…</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()<br>深拷贝：</li><li>JSON.parse(JSON.stringify())</li><li>lodash.cloneDeep</li><li>jQuery.extend()</li><li>手写递归方法</li></ul><h2 id="JSON-stringify有什么缺点？"><a href="#JSON-stringify有什么缺点？" class="headerlink" title="JSON.stringify有什么缺点？"></a>JSON.stringify有什么缺点？</h2><ol><li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</li><li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li><li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li><li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；<br>6、如果对象中存在循环引用的情况也无法正确实现深拷贝；</li></ol><h2 id="函数执行作用域"><a href="#函数执行作用域" class="headerlink" title="函数执行作用域"></a>函数执行作用域</h2><p>函数执行时做的事情</p><ol><li>确定作用域链： 当前执行上下文，上级执行上下文</li><li>确定this指向：window</li><li>初始化arguments对象</li><li>形参赋值</li><li>执行代码</li></ol><h2 id="js阴间面试题"><a href="#js阴间面试题" class="headerlink" title="js阴间面试题"></a>js阴间面试题</h2><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!==0.3"></a>0.1+0.2!==0.3</h3><p>原因总结：<br>进制转换 ：js 在做数字计算的时候，<strong>0.1 和 0.2 都会被转成二进制后无限循环</strong>，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。<br>对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。</p><p>解决办法：</p><ol><li>转为整数（大数）运算。</li><li>使用 Number.EPSILON 误差范围。</li><li>转成字符串，对字符串做加法运算。</li></ol><h3 id="后端返回一万条数据"><a href="#后端返回一万条数据" class="headerlink" title="后端返回一万条数据"></a>后端返回一万条数据</h3><ol><li>直接渲染</li><li>setTimeOut分片渲染，每次默认渲染200条</li><li>requestAnimationFrame，用createElement创建列表元素，减少重排次数</li><li>requestAnimationFrame，用document.createDocumentFragment方法创建列表元素，不会触发DOM树的重新渲染</li><li>在页面中加入空元素，监听空元素是否存在，当存在的时候加载下一页</li><li>虚拟列表</li></ol><p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519a393dee2c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="虚拟列表"></p><p><strong>虚拟列表</strong></p><p>计算当前可视区域起始数据索引(startIndex)<br>计算当前可视区域结束数据索引(endIndex)<br>计算当前可视区域的数据，并渲染到页面中<br>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上</p><p>上述实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p><p>可以以预估高度先行渲染，然后获取真实高度并缓存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}body::-webkit-scrollbar {  width: 0;}.neko {  width: 64px;  height: 64px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812db74be9.png");  position: absolute;  right: 32px;  background-repeat: no-repeat;  background-size: contain;  transform: translateX(50%);  cursor: pointer;  font-family: tzy;  font-weight: 600;  font-size: 16px;  color: #6f42c1;  display: none;}.neko::after {  display: none;  width: 100px;  height: 100px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812d95e6f5.png");  background-size: contain;  z-index: 9999;  position: absolute;  right: 50%;  text-align: center;  line-height: 100px;  top: -115%;}.neko.showMsg::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko:hover::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko.fontColor::after {  color: #333;}/*** @description: 滚动条样式  跟猫二选一*/@media screen and (max-width:992px) {  ::-webkit-scrollbar {      width: 8px !important;      height: 8px !important  }  ::-webkit-scrollbar-track {      border-radius: 2em;  }  ::-webkit-scrollbar-thumb {      background-color: rgb(255 255 255 / .3);      background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);      border-radius: 2em  }  ::-webkit-scrollbar-corner {      background-color: transparent  }}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {  -webkit-animation: ccc 4s linear infinite;  animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}@keyframes ccc {  0% {    -webkit-transform: rotate(0deg);    transform: rotate(0deg);  }  to {    -webkit-transform: rotate(-1turn);    transform: rotate(-1turn);  }}/* 设置风车颜色 */#content-inner.layout h1::before {  color: #ef50a8;  margin-left: -1.55rem;  font-size: 1.3rem;  margin-top: -0.23rem;}#content-inner.layout h2::before {  color: #fb7061;  margin-left: -1.35rem;  font-size: 1.1rem;  margin-top: -0.12rem;}#content-inner.layout h3::before {  color: #ffbf00;  margin-left: -1.22rem;  font-size: 0.95rem;  margin-top: -0.09rem;}#content-inner.layout h4::before {  color: #a9e000;  margin-left: -1.05rem;  font-size: 0.8rem;  margin-top: -0.09rem;}#content-inner.layout h5::before {  color: #57c850;  margin-left: -0.9rem;  font-size: 0.7rem;  margin-top: 0rem;}#content-inner.layout h6::before {  color: #5ec1e0;  margin-left: -0.9rem;  font-size: 0.66rem;  margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {  color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {  color: var(--theme-color);  -webkit-animation: ccc 6s linear infinite;  animation: ccc 6s linear infinite;}/* 雪花特效 */[data-theme="light"] #snow{  display: block;  position: fixed;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  z-index: -2;}/* 雪花黑夜模式不显示 */[data-theme="dark"] #snow{  display: none;}/* 页面样式调节 */:root {  --trans-light: rgba(255, 255, 255, 0.95);  --trans-dark: rgba(25, 25, 25, 0.95);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.95);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.95) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'XWWK';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/霞鹜文楷.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cat.js"/>
      <url>/js/cat.js</url>
      
        <content type="html"><![CDATA[if (document.body.clientWidth > 992) {  function getBasicInfo() {      /* 窗口高度 */      var ViewH = $(window).height();      /* document高度 */      var DocH = $("body")[0].scrollHeight;      /* 滚动的高度 */      var ScrollTop = $(window).scrollTop();      /* 可滚动的高度 */      var S_V = DocH - ViewH;      var Band_H = ScrollTop / (DocH - ViewH) * 100;      return {          ViewH: ViewH,          DocH: DocH,          ScrollTop: ScrollTop,          Band_H: Band_H,          S_V: S_V      }  };  function show(basicInfo) {      if (basicInfo.ScrollTop > 0.001) {          $(".neko").css('display', 'block');      } else {          $(".neko").css('display', 'none');      }  }  (function ($) {      $.fn.nekoScroll = function (option) {          var defaultSetting = {              top: '0',              scroWidth: 6 + 'px',              z_index: 9999,              zoom: 0.9,              borderRadius: 5 + 'px',              right: 60 + 'px',              nekoImg: "https://bu.dusays.com/2022/07/20/62d812db74be9.png",              hoverMsg: "喵喵喵~",              color: "#6f42c1",              during: 500,              blog_body: "body",          };          var setting = $.extend(defaultSetting, option);          var getThis = this.prop("className") !== "" ? "." + this.prop("className") : this.prop("id") !== "" ? "#" +              this.prop("id") : this.prop("nodeName");          if ($(".neko").length == 0) {              this.after("<div class="\"neko\"" id=" + setting.nekoname + " data-msg="\""" + setting.hovermsg "\"></div>");          }          let basicInfo = getBasicInfo();          $(getThis)              .css({                  'position': 'fixed',                  'width': setting.scroWidth,                  'top': setting.top,                  'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                  'z-index': setting.z_index,                  'background-color': setting.bgcolor,                  "border-radius": setting.borderRadius,                  'right': setting.right,                  'background-image': 'url(' + setting.scImg + ')',                  'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                  'background-size': 'contain'              });          $("#" + setting.nekoname)              .css({                  'position': 'fixed',                  'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                  'z-index': setting.z_index * 10,                  'right': setting.right,                  'background-image': 'url(' + setting.nekoImg + ')',              });          show(getBasicInfo());          $(window)              .scroll(function () {                  let basicInfo = getBasicInfo();                  show(basicInfo);                  $(getThis)                      .css({                          'position': 'fixed',                          'width': setting.scroWidth,                          'top': setting.top,                          'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',                          'z-index': setting.z_index,                          'background-color': setting.bgcolor,                          "border-radius": setting.borderRadius,                          'right': setting.right,                          'background-image': 'url(' + setting.scImg + ')',                          'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',                          'background-size': 'contain'                      });                  $("#" + setting.nekoname)                      .css({                          'position': 'fixed',                          'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',                          'z-index': setting.z_index * 10,                          'right': setting.right,                          'background-image': 'url(' + setting.nekoImg + ')',                      });                  if (basicInfo.ScrollTop == basicInfo.S_V) {                      $("#" + setting.nekoname)                          .addClass("showMsg")                  } else {                      $("#" + setting.nekoname)                          .removeClass("showMsg");                      $("#" + setting.nekoname)                          .attr("data-msg", setting.hoverMsg);                  }              });          this.click(function (e) {              btf.scrollToDest(0, 500)          });          $("#" + setting.nekoname)              .click(function () {                  btf.scrollToDest(0, 500)              });          return this;      }  })(jQuery);  $(document).ready(function () {      //部分自定义      $("#myscoll").nekoScroll({          bgcolor: 'rgb(0 0 0 / .5)', //背景颜色，没有绳子背景图片时有效          borderRadius: '2em',          zoom: 0.9      }      );      //自定义（去掉以下注释，并注释掉其他的查看效果）      /*      $("#myscoll").nekoScroll({          nekoname:'neko1', //nekoname，相当于id          nekoImg:'img/猫咪.png', //neko的背景图片          scImg:"img/绳1.png", //绳子的背景图片          bgcolor:'#1e90ff', //背景颜色，没有绳子背景图片时有效          zoom:0.9, //绳子长度的缩放值          hoverMsg:'你好~喵', //鼠标浮动到neko上方的对话框信息          right:'100px', //距离页面右边的距离          fontFamily:'楷体', //对话框字体          fontSize:'14px', //对话框字体的大小          color:'#1e90ff', //对话框字体颜色          scroWidth:'8px', //绳子的宽度          z_index:100, //不用解释了吧          during:1200, //从顶部到底部滑动的时长      });      */  })}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {  window.requestAnimationFrame =    window.requestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.msRequestAnimationFrame;  var n,    e,    i,    h,    t = 0.05,    s = document.getElementById("universe"),    o = !0,    a = "180,184,240",    r = "226,225,142",    d = "226,225,224",    c = [];  function f() {    (n = window.innerWidth),      (e = window.innerHeight),      (i = 0.216 * n),      s.setAttribute("width", n),      s.setAttribute("height", e);  }  function u() {    h.clearRect(0, 0, n, e);    for (var t = c.length, i = 0; i < t; i++) {      var s = c[i];      s.move(), s.fadeIn(), s.fadeOut(), s.draw();    }  }  function y() {    (this.reset = function () {      (this.giant = m(3)),        (this.comet = !this.giant && !o && m(10)),        (this.x = l(0, n - 10)),        (this.y = l(0, e)),        (this.r = l(1.1, 2.6)),        (this.dx = l(t, 6 * t) + (this.comet + 1 - 1) * t * l(50, 120) + 2 * t),        (this.dy = -l(t, 6 * t) - (this.comet + 1 - 1) * t * l(50, 120)),        (this.fadingOut = null),        (this.fadingIn = !0),        (this.opacity = 0),        (this.opacityTresh = l(0.2, 1 - 0.4 * (this.comet + 1 - 1))),        (this.do = l(5e-4, 0.002) + 0.001 * (this.comet + 1 - 1));    }),      (this.fadeIn = function () {        this.fadingIn &&          ((this.fadingIn = !(this.opacity > this.opacityTresh)),          (this.opacity += this.do));      }),      (this.fadeOut = function () {        this.fadingOut &&          ((this.fadingOut = !(this.opacity < 0)),          (this.opacity -= this.do / 2),          (this.x > n || this.y < 0) && ((this.fadingOut = !1), this.reset()));      }),      (this.draw = function () {        if ((h.beginPath(), this.giant))          (h.fillStyle = "rgba(" + a + "," + this.opacity + ")"),            h.arc(this.x, this.y, 2, 0, 2 * Math.PI, !1);        else if (this.comet) {          (h.fillStyle = "rgba(" + d + "," + this.opacity + ")"),            h.arc(this.x, this.y, 1.5, 0, 2 * Math.PI, !1);          for (var t = 0; t < 30; t++)            (h.fillStyle =              "rgba(" +              d +              "," +              (this.opacity - (this.opacity / 20) * t) +              ")"),              h.rect(                this.x - (this.dx / 4) * t,                this.y - (this.dy / 4) * t - 2,                2,                2              ),              h.fill();        } else          (h.fillStyle = "rgba(" + r + "," + this.opacity + ")"),            h.rect(this.x, this.y, this.r, this.r);        h.closePath(), h.fill();      }),      (this.move = function () {        (this.x += this.dx),          (this.y += this.dy),          !1 === this.fadingOut && this.reset(),          (this.x > n - n / 4 || this.y < 0) && (this.fadingOut = !0);      }),      setTimeout(function () {        o = !1;      }, 50);  }  function m(t) {    return Math.floor(1e3 * Math.random()) + 1 < 10 * t;  }  function l(t, i) {    return Math.random() * (i - t) + t;  }  f(),    window.addEventListener("resize", f, !1),    (function () {      h = s.getContext("2d");      for (var t = 0; t < i; t++) (c[t] = new y()), c[t].reset();      u();    })(),    (function t() {      document.getElementsByTagName("html")[0].getAttribute("data-theme") ==        "dark" && u(),        window.requestAnimationFrame(t);    })();}dark();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/snow.js"/>
      <url>/js/snow.js</url>
      
        <content type="html"><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {  // 移动端不显示} else {  // document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');  window && (() => {      let e = {          flakeCount: 50, // 雪花数目          minDist: 150,   // 最小距离          color: "255, 255, 255", // 雪花颜色          size: 1.5,  // 雪花大小          speed: .5,  // 雪花速度          opacity: .7,    // 雪花透明度          stepsize: .5    // 步距      };      const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {          window.setTimeout(e, 1e3 / 60)      }          ;      window.requestAnimationFrame = t;      const i = document.getElementById("snow"),          n = i.getContext("2d"),          o = e.flakeCount;      let a = -100,          d = -100,          s = [];      i.width = window.innerWidth,          i.height = window.innerHeight;      const h = () => {          n.clearRect(0, 0, i.width, i.height);          const r = e.minDist;          for (let t = 0; t < o; t++) {              let o = s[t];              const h = a,                  w = d,                  m = o.x,                  c = o.y,                  p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));              if (p < r) {                  const e = (h - m) / p,                      t = (w - c) / p,                      i = r / (p * p) / 2;                  o.velX -= i * e,                      o.velY -= i * t              } else                  o.velX *= .98,                      o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),                      o.velX += Math.cos(o.step += .05) * o.stepSize;              n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",                  o.y += o.velY,                  o.x += o.velX,                  (o.y >= i.height || o.y <= 0) && l(o), (o.x>= i.width || o.x <= 2 0) && l(o), n.beginpath(), n.arc(o.x, o.y, o.size, 0, * math.pi), n.fill() } t(h) , l="e" => {              e.x = Math.floor(Math.random() * i.width),                  e.y = 0,                  e.size = 3 * Math.random() + 2,                  e.speed = 1 * Math.random() + .5,                  e.velY = e.speed,                  e.velX = 0,                  e.opacity = .5 * Math.random() + .3          }          ;      document.addEventListener("mousemove", (e => {          a = e.clientX,              d = e.clientY      }      )),          window.addEventListener("resize", (() => {              i.width = window.innerWidth,                  i.height = window.innerHeight          }          )),          (() => {              for (let t = 0; t < o; t++) {                  const t = Math.floor(Math.random() * i.width)                      , n = Math.floor(Math.random() * i.height)                      , o = 3 * Math.random() + e.size                      , a = 1 * Math.random() + e.speed                      , d = .5 * Math.random() + e.opacity;                  s.push({                      speed: a,                      velX: 0,                      velY: a,                      x: t,                      y: n,                      size: o,                      stepSize: Math.random() / 30 * e.stepsize,                      step: 0,                      angle: 180,                      opacity: d                  })              }              h()          }          )()  }  )();}</=></=>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
