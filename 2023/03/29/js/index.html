<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>js | 豆豆想吃骨头</title><meta name="author" content="happy"><meta name="copyright" content="happy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据类型 基本数据类型Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增） 引用数据类型普通对象，数组对象，正则对象，日期对象，Math数学函数对象。 包装数据类型Number，String，Boolean  两种数据存储方式：  基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本">
<meta property="og:type" content="article">
<meta property="og:title" content="js">
<meta property="og:url" content="http://example.com/2023/03/29/js/index.html">
<meta property="og:site_name" content="豆豆想吃骨头">
<meta property="og:description" content="数据类型 基本数据类型Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增） 引用数据类型普通对象，数组对象，正则对象，日期对象，Math数学函数对象。 包装数据类型Number，String，Boolean  两种数据存储方式：  基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E7%89%8C%E7%89%8Cjs.png">
<meta property="article:published_time" content="2023-03-29T13:47:51.000Z">
<meta property="article:modified_time" content="2023-04-06T13:58:07.622Z">
<meta property="article:author" content="happy">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E7%89%8C%E7%89%8Cjs.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/29/js/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 21:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/%E7%89%8C%E7%89%8Cjs.png')"><nav id="nav"><span id="blog-info"><a href="/" title="豆豆想吃骨头"><span class="site-name">豆豆想吃骨头</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-29T13:47:51.000Z" title="发表于 2023-03-29 21:47:51">2023-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-06T13:58:07.622Z" title="更新于 2023-04-06 21:58:07">2023-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型<br><strong>Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）</strong></li>
<li>引用数据类型<br><strong>普通对象，数组对象，正则对象，日期对象，Math数学函数对象。</strong></li>
<li>包装数据类型<br><strong>Number，String，Boolean</strong></li>
</ul>
<p><strong>两种数据存储方式：</strong></p>
<ul>
<li>基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基本类型值和执行代码的空间。</li>
<li>引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p><strong>两种数据类型的区别：</strong></p>
<ul>
<li>堆比栈空间大，栈比堆运行速度快。</li>
<li>堆内存是无序存储，可以根据引用直接获取。</li>
<li>基础数据类型比较稳定，而且相对来说占用的内存小。</li>
<li>引用数据类型大小是动态的，而且是无限的。</li>
</ul>
<p>BigInt类型<br>BigInt数据类型提供了一种方法来表示大于2^53^-1的整数。BigInt可以表示任意大的整数。</p>
<p>Symbol类型<br>Symbol 是一种在ES6 中新添加的数据类型，本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值，同时具备隐藏性（for in不能访问）。</p>
<h2 id="js常见函数"><a href="#js常见函数" class="headerlink" title="js常见函数"></a>js常见函数</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign(target, …sources)</p>
<p><strong>Object.assign会将source里面的可枚举属性复制到target</strong>，如果和target的已有属性重名，则会覆盖。后续的source会覆盖前面的source的同名属性。Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a,<span class="string">&quot;b&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">value</span>:<span class="number">123</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<p>第一个参数：目标对象<br>第二个参数：需要定义的属性或方法的名字。<br>第三个参数：目标属性所拥有的特性。（descriptor）</p>
<h3 id="可枚举属性"><a href="#可枚举属性" class="headerlink" title="可枚举属性"></a>可枚举属性</h3><p>可枚举可以理解为是否可以被遍历被列举出来，可枚举性决定了这个属性能否被<strong>for…in</strong>查找遍历到。<br>js中基本包装类型的原型属性是不可枚举的（不可被 for…in… 遍历），比如：Boolean,Number和String三个的原型属性，或是 Boolean,Number值，都是不可枚举的，即是基本类型。基本包装类型还可以像引用类型一样访问它自带的一些方法，但是不能像引用类型那样自定义方法。</p>
<p>判断属性是否可枚举<br>1.<strong>for…in</strong><br>2.<strong>propertyIsEnumerable( )</strong> 方法返回一个布尔值，表示属性是否可以枚举</p>
<p>每个对象都有一个propertyIsEnumerable方法。该方法可以确定对象中的指定属性是否可以通过for…in循环枚举，但通过原型链继承的属性除外。如果对象不具有指定的属性，则此方法返回false。</p>
<h3 id="String-prototype"><a href="#String-prototype" class="headerlink" title="String.prototype"></a>String.prototype</h3><p>String.prototype用于为某字符串对象新增方法</p>
<h3 id="forEach、filter、map、some、every、find、findIndex、reduce"><a href="#forEach、filter、map、some、every、find、findIndex、reduce" class="headerlink" title="forEach、filter、map、some、every、find、findIndex、reduce"></a>forEach、filter、map、some、every、find、findIndex、reduce</h3><p>这里有一堆土豆，如果换成代码，可以表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potatos = [&#123; <span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="attr">weight</span>: <span class="number">50</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1002&#x27;</span>, <span class="attr">weight</span>: <span class="number">80</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1003&#x27;</span>, <span class="attr">weight</span>: <span class="number">120</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1004&#x27;</span>, <span class="attr">weight</span>: <span class="number">40</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1005&#x27;</span>, <span class="attr">weight</span>: <span class="number">110</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;1006&#x27;</span>, <span class="attr">weight</span>: <span class="number">60</span> &#125;]</span><br></pre></td></tr></table></figure>

<p>同时把上面的重量（g）记录成一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = [<span class="number">50</span>, <span class="number">80</span>, <span class="number">120</span>, <span class="number">40</span>, <span class="number">110</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure>

<h4 id="批量操作-foreach"><a href="#批量操作-foreach" class="headerlink" title="批量操作 foreach"></a>批量操作 foreach</h4><p>数组里所有元素的weight增加，修改原数组，无返回值<br>map可实现，但不修改原数组，返回新数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">potatos.<span class="title function_">forEach</span>(<span class="function"><span class="params">potato</span> =&gt;</span> potato.<span class="property">weight</span> += <span class="number">20</span> )</span><br></pre></td></tr></table></figure>

<h4 id="生成原始数据的特征信息map"><a href="#生成原始数据的特征信息map" class="headerlink" title="生成原始数据的特征信息map"></a>生成原始数据的特征信息map</h4><p>map最适合做的事是映射，生成原始数据的特征信息的map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = potatos.<span class="title function_">map</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> += <span class="number">20</span> &#125;)</span><br><span class="line"><span class="comment">//[ 70, 100, 140, 60, 130, 80 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="筛选过滤filter"><a href="#筛选过滤filter" class="headerlink" title="筛选过滤filter"></a>筛选过滤filter</h4><p>filter是滤波的意思 从名字上看，就知道筛选过滤这样的活是filter<br>返回一个新的对象数组，并不会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigOnes = potatos.<span class="title function_">filter</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//[ &#123; id: &#x27;1003&#x27;, weight: 120 &#125;, &#123; id: &#x27;1005&#x27;, weight: 110 &#125; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="判断数组中有没有符合条件的时候some"><a href="#判断数组中有没有符合条件的时候some" class="headerlink" title="判断数组中有没有符合条件的时候some"></a>判断数组中有没有符合条件的时候some</h4><p>当只需要判断数组中有没有符合条件的时候（一个就行） 就需要我们的some方法登场了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasbig = potatos.<span class="title function_">some</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>我们的some小伙计，去土豆存放的仓库进行寻找，只要找到一个符合条件的，就回来报告true 所以并不会全部遍历，不做多余的活（性能优良）</p>
<h4 id="判断数组元素是否全符合every"><a href="#判断数组元素是否全符合every" class="headerlink" title="判断数组元素是否全符合every"></a>判断数组元素是否全符合every</h4><p>every对每一个元素执行一个callback，直到它找到一个使 callback 返回 false的元素（没那么大的土豆），就返回false，直到遍历完成也没有返回false的话，就返回true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allbig = potatos.<span class="title function_">every</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="寻找数组元素中一个符合的find"><a href="#寻找数组元素中一个符合的find" class="headerlink" title="寻找数组元素中一个符合的find"></a>寻找数组元素中一个符合的find</h4><p>来了一个顾客，想要一个大土豆 find自告奋勇，我去找给他</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> big = potatos.<span class="title function_">find</span>(<span class="function"><span class="params">potato</span> =&gt;</span> &#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//&#123; id: &#x27;1003&#x27;, weight: 120 &#125;</span></span><br></pre></td></tr></table></figure>

<p>find和some很类似，都是寻找符合条件的，有一个就可以 不过some进去搜罗了一圈回来报了个“有”（true），而find则把那个土豆抱了出来（返回第一个符合条件的对象）</p>
<h4 id="当需要知道所需元素的索引findIndex"><a href="#当需要知道所需元素的索引findIndex" class="headerlink" title="当需要知道所需元素的索引findIndex"></a>当需要知道所需元素的索引findIndex</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = potatos.<span class="title function_">findIndex</span>(<span class="function"><span class="params">potato</span>=&gt;</span>&#123; <span class="keyword">return</span> potato.<span class="property">weight</span> &gt; <span class="number">100</span> &#125;)</span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>当需要知道所需元素的索引，就可以用findIndex，findIndex返回第一个符合条件的索引号</p>
<h4 id="递归累加reduce"><a href="#递归累加reduce" class="headerlink" title="递归累加reduce"></a>递归累加reduce</h4><p><img src="/2023/03/29/js/image-20230406164330104.png" alt="image-20230406164330104"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), initialValue)</span><br><span class="line"><span class="keyword">var</span> sum = weight.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, w</span>) =&gt;</span> &#123; <span class="keyword">return</span> w + sum &#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//460</span></span><br><span class="line"><span class="comment">//并不会改变原表格</span></span><br></pre></td></tr></table></figure>

<p>如果初始值不传：开始时total的值为数组的第一项。</p>
<p>计算一个字符串中每个字母出现次数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;jshdjsihh&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> &#123;</span><br><span class="line">	total[cur] ? total[cur] ++ : total[cur] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123;j: 2, s: 2, h: 3, d: 1, i: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="常见数据类型检测的方式"><a href="#常见数据类型检测的方式" class="headerlink" title="常见数据类型检测的方式"></a>常见数据类型检测的方式</h3><p><strong>typeof</strong></p>
<p>其中数组、对象、null都会被判断为Object，其他判断都正确</p>
<p><strong>instanceof</strong></p>
<p>只能判断引用数据类型,不能判断基本数据类型</p>
<p><strong>constructor</strong></p>
<p>一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了</p>
<p><strong>Object.prototype.toString.call()</strong></p>
<p>无论是Array,还是Date，所有数据类型。都是从对象衍生而来的。本质上，Array和Date还有Function啥的他们就是对象。虽然他们都被称为对象，对象也是有很多类型的。比如Date,他就是时间对象‘ [object Date] ’, Array,他就是数组对象‘[object Array]’等等。简而言之，js中所有的数据类型，都只是对象的一种类型。所以，js中有一句话叫，万物皆对象。而<strong>Object.prototype.toString() 这个函数作用就是，返回当前调用者的对象类型。</strong></p>
<p>因为Object.prototype.toString()返回的是调用者的类型。不论你toString()本身的入参写的是什么，在Object.prototype.toString()中，他的调用者永远都是Object.prototype；所以，在不加call()情况下，我们的出来的结果永远都是 ‘[object Object]’</p>
<p><strong>isNaN 检测数据是否是数字</strong></p>
<p><strong>Array.isArray()检测数据是否是数组</strong></p>
<h3 id="slice、splice、split"><a href="#slice、splice、split" class="headerlink" title="slice、splice、split"></a>slice、splice、split</h3><p><strong>slice(start,[end])</strong></p>
<p>slice(start,[end])方法：该方法是对数组进行部分截取，该方法返回一个新数组<br>不会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">/*console.log(arr.slice(3))//[4,5,6] 从下标为0的到3，截取3之后的数</span></span><br><span class="line"><span class="comment">console.log(arr.slice(0,3))//[1,2,3] 从下标为0的地方截取到下标为3之前的数</span></span><br><span class="line"><span class="comment">console.log(arr.slice(0,-2))//[1,2,3,4]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-4,4))//[3,4]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-7))//[1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">console.log(arr.slice(-3,-3))// []</span></span><br><span class="line"><span class="comment">console.log(arr.slice(8))//[]*/</span></span><br><span class="line"><span class="comment">// 个人总结：slice的参数如果是正数就从左往右数，如果是负数的话就从右往左边数，</span></span><br><span class="line"><span class="comment">// 截取的数组与数的方向一致，如果是2个参数则截取的是数的交集，没有交集则返回空数组</span></span><br><span class="line"><span class="comment">// ps：slice也可以切割字符串，用法和数组一样，但要注意空格也算字符</span></span><br></pre></td></tr></table></figure>

<p><strong>splice(start,deletecount,item)</strong></p>
<p>start：起始位置  deletecount：删除位数    item：替换的item<br>返回值为被删除的字符串<br>如果有额外的参数，那么item会插入到被移除元素的位置上。<br>splice:移除，splice方法从array中移除一个或多个数组，并用新的item替换它们。<br>举一个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//[&#x27;a&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//[&#x27;b&#x27;]</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//console.log(&quot;被删除的为：&quot;,a.splice(1, 1, 8, 9)); //被删除的为：2</span></span><br><span class="line"><span class="comment">// console.log(&quot;a数组元素：&quot;,a); //1,8,9,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(&quot;被删除的为：&quot;, a.splice(0, 2)); //被删除的为：1,2</span></span><br><span class="line"><span class="comment">// console.log(&quot;a数组元素：&quot;, a) //3,4,5,6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;被删除的为：&quot;</span>, a.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)) <span class="comment">//插入 第二个数为0，表示删除0个  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a数组元素：&quot;</span>, a) <span class="comment">//1,2,2,2,3,4,5,6</span></span><br></pre></td></tr></table></figure>

<p><strong>split(字符串)</strong></p>
<p>string.split(separator,limit)：split方法把这个string分割成片段来创建一个字符串数组。<br>可选参数limit可以限制被分割的片段数量。<br>separator参数可以是一个字符串或一个正则表达式。<br>如果separator是一个空字符，会返回一个单字符的数组，不会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">&quot;0123456&quot;</span>;  </span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="comment">//b=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<p>注意：String.split() 执行的操作与 Array.join 执行的操作是相反的。</p>
<h3 id="for-in、Object-keys和for-of"><a href="#for-in、Object-keys和for-of" class="headerlink" title="for in、Object.keys和for-of"></a>for in、Object.keys和for-of</h3><p><strong>for-in</strong><br>for … in是为遍历对象属性而构建的，<br>主要用于遍历对象的<strong>可枚举属性</strong>，包括自有属性、继承自原型的属性</p>
<p><strong>for-of</strong><br>es6 中添加的循环遍历语法；<br>支持遍历数组，类数组对象（DOM NodeList），字符串，Map 对象，Set 对象；<br>不支持遍历对象； 遍历后输出的结果为数组元素的值</p>
<p><strong>Object.keys()</strong><br>对数组的遍历顺序和 for in 一致<br>此方法返回一个数组，元素均为对象自有可枚举的属性<br>Object.keys主要用于遍历对象自有的可枚举属性，不包括继承自原型的属性和不可枚举的属性</p>
<p><strong>Object.getOwnProperty</strong><br>此方法用于返回对象的自有属性，包括可枚举和不可枚举的属性</p>
<h2 id="var、function变量、函数提升"><a href="#var、function变量、函数提升" class="headerlink" title="var、function变量、函数提升"></a>var、function变量、函数提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数内声明提升，所以上面的代码实际上是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> scope;    <span class="comment">//变量声明提升到函数顶部</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">    scope = <span class="string">&#x27;local&#x27;</span>;    <span class="comment">//变量初始化依然保留在原来的位置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过这样变形之后，答案就就非常明显了。由于scope在第一个console.log(scope)语句之前就已经定义了，但是并没有赋值，因此此时scope的指是undefined.第二个console.log(scope)语句之前，scope已经完成赋值为’local’，所以输出的结果是local。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式为变量声明，变量声明提升优先级较低</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数声明，函数声明提升优先级更高</span></span><br><span class="line"><span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p>让我们来分析一下，这个例子涉及到了变量声明提升和函数声明提升。正如前面说到的函数声明提升，函数声明function getName(){}的声明会被提前到顶部。而函数表达式var getName = function(){}则表现出变量声明提升。因此在这种情况下，getName也是一个变量，因此这个变量的声明也将提升到底部，而变量的赋值依然保留在原来的位置。<strong>需要注意的是，函数优先，虽然函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量</strong>。因此上面的函数可以转换成下面的样子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;    <span class="comment">//函数声明提升到顶部</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName;    <span class="comment">//变量声明提升</span></span><br><span class="line">getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">//变量赋值依然保留在原来的位置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getName</span>();    <span class="comment">// 最终输出：2</span></span><br></pre></td></tr></table></figure>

<p>所以最终的输出结果是：2。在原来的例子中，函数声明虽然是在函数表达式后面，但由于函数声明提升到顶部，因此后面getName又被函数表达式的赋值操作给覆盖了，所以输出2。</p>
<h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 id="parseInt方法"><a href="#parseInt方法" class="headerlink" title="parseInt方法"></a>parseInt方法</h3><p><code>parseInt(string, radix)</code>方法用于解析字符串，并返回一个整数</p>
<p>接收两个参数：<code>string</code>和<code>radix</code>，<code>string</code>为需要解析的字符串，<code>radix</code>为进制数，也就是将字符串按照几进制进行解析，当<code>radix</code>为2，表示将字符串按照二进制解析</p>
<h3 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h3><p>扩展运算符由三个点 (…) 表示。主要用于扩展、展开对象，数组等等</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统字符串，使用单引号 ‘ ‘ 或者双引号 “ “ ; 模板字符串使用反单引号 ``，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world&#x27;</span>;<span class="comment">//传统字符串</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;hello world&quot;</span>;<span class="comment">//传统字符串</span></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">`hello world`</span>;<span class="comment">//模板字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>模板字符串可以插入表达式 （重点）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>: <span class="number">14</span>,</span><br><span class="line">	<span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bio = <span class="string">`name: <span class="subst">$&#123;xiaoming.name&#125;</span>, age: <span class="subst">$&#123;xiaoming.age&#125;</span>, sex: <span class="subst">$&#123;xiaoming.sex&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="异步Promise、Generator和Async"><a href="#异步Promise、Generator和Async" class="headerlink" title="异步Promise、Generator和Async"></a>异步Promise、Generator和Async</h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>包装了一个异步调用并生成一个Promise实例，当异步调用返回的时候根据调用的结果分别调用实例化时传入的resolve和reject方法，then接收到对应的数据，做出相应的处理。Promise不仅能够捕获错误，而且也能很好地解决了回调地狱的问题，缺点是无法取消Promise，错误需要通过回调函数捕获。</p>
<p><strong>Promise 是什么</strong></p>
<ul>
<li>Promise 是异步操作的一种解决方案</li>
<li>Promise 一般用来解决层层嵌套的回调函数（回调地狱 callback hell）的问题</li>
</ul>
<p><strong>基本用法</strong></p>
<p>实例化构造函数生成实例对象</p>
<p>Promise 解决的不是回调函数，而是回调地狱</p>
<p><code>const p = new Promise(() =&gt; &#123;&#125;);</code></p>
<p>Promise 的状态：</p>
<ul>
<li>Promise 有 3 种状态，一开始是 pending（未完成）</li>
<li>执行 resolve，变成 fulfilled (resolved)，已成功</li>
<li>执行 reject，变成 rejected，已失败</li>
<li>Promise 的状态一旦变化，就不会再改变了</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// pending-&gt;fulfilled</span></span><br><span class="line">	<span class="title function_">resolve</span>();</span><br><span class="line">	<span class="comment">// pending-&gt;rejected</span></span><br><span class="line">	<span class="title function_">reject</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>then 方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>resolve 和 reject 函数的参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// resolve(&#x27;succ&#x27;);</span></span><br><span class="line">	<span class="comment">// 也可以传一些数据</span></span><br><span class="line">	<span class="title function_">resolve</span>(&#123; <span class="attr">username</span>: <span class="string">&#x27;mike&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">	<span class="comment">// 比较常用的是传一个错误对象</span></span><br><span class="line">	<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;reason&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">	<span class="comment">// 在 then 方法中接收数据</span></span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, data);	<span class="comment">//success &#123;username: &quot;mike&quot;&#125;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, err);	<span class="comment">// error reason</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Promise-的实例方法"><a href="#Promise-的实例方法" class="headerlink" title="Promise 的实例方法"></a>Promise 的实例方法</h5><p><strong>then()</strong></p>
<p>什么时候执行：<br>    pending —&gt; fulfilled 时，执行 then 的第一个回调函数<br>    pending —&gt; rejected 时，执行 then 的第二个回调函数<br>    状态不改变，then() 的回调函数都不会被执行<br>执行后的返回值：<br>then 方法执行后返回一个新的 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>();</span><br><span class="line">	<span class="comment">// reject();</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p</span><br><span class="line">	.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">		<span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">	)</span><br><span class="line">	.<span class="title function_">then</span>()</span><br><span class="line">	.<span class="title function_">then</span>();</span><br></pre></td></tr></table></figure>
<p>then 方法返回的 Promise 对象的状态改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>();</span><br><span class="line">	<span class="comment">// reject();</span></span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在 then 的回调函数中，return 后面的东西，会用 Promise 包装一下</span></span><br><span class="line">		<span class="comment">// return undefined;</span></span><br><span class="line">		<span class="comment">// 等价于</span></span><br><span class="line">		<span class="comment">// return new Promise(resolve =&gt; &#123;</span></span><br><span class="line">		<span class="comment">//   resolve(undefined);</span></span><br><span class="line">		<span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// return 123;</span></span><br><span class="line">		<span class="comment">// 等价于</span></span><br><span class="line">		<span class="comment">// return new Promise(resolve =&gt; &#123;</span></span><br><span class="line">		<span class="comment">//   resolve(123);</span></span><br><span class="line">		<span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认返回的永远都是成功状态的 Promise 对象</span></span><br><span class="line">		<span class="comment">// 主动设置为失败</span></span><br><span class="line">		<span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">		<span class="comment">//   reject(&#x27;reason&#x27;);</span></span><br><span class="line">		<span class="comment">// &#125;);</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success2&#x27;</span>, data);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return undefined;</span></span><br><span class="line">		<span class="comment">// 默认</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err2&#x27;</span>, err);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success3&#x27;</span>, data);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err3&#x27;</span>, err);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>catch()</strong></p>
<p>catch 的作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 一般只写第一个回调用来处理成功的...</span></span><br><span class="line"><span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 可以理解为用 then 专门处理成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以用 catch 专门用来处理 rejected 状态<br> catch 本质上是 then 的特例 <code>then(null, err =&gt; &#123;&#125;);</code></p>
<p>基本用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// .then(null, err =&gt; &#123;</span></span><br><span class="line">	<span class="comment">// 	console.log(err);</span></span><br><span class="line">	<span class="comment">// &#125;);</span></span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// return undefined;</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// catch() 可以捕获它前面的错误</span></span><br><span class="line"><span class="comment">// 一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误</span></span><br></pre></td></tr></table></figure>

<p><strong>finally()</strong></p>
<ul>
<li>什么时候执行：<br> 当 Promise 状态发生变化时，不论如何变化都会执行，不变化不执行</li>
<li>本质：<br> finally() 本质上是 then() 的特例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// resolve(123);</span></span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.<span class="title function_">finally</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// resolve(123);</span></span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">reject</span>(err);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Promise-的构造函数方法"><a href="#Promise-的构造函数方法" class="headerlink" title="Promise 的构造函数方法"></a>Promise 的构造函数方法</h5><p><strong>Promise.resolve()</strong></p>
<ul>
<li>是成功状态 Promise 的一种简写形式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数：</li>
</ul>
<p>1）一般参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2）特殊参数：Promise 对象<br>当 Promise.resolve() 接收的是 Promise 对象时，直接返回这个 Promise 对象，什么都不做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;我执行了&#x27;</span>);</span><br><span class="line">	<span class="comment">// 等价于</span></span><br><span class="line">	<span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">	<span class="comment">//   resolve(&#x27;我执行了&#x27;);</span></span><br><span class="line">	<span class="comment">// &#125;, 1000);</span></span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p1).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// p1.then(data =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	console.log(data);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// console.log(Promise.resolve(p1) === p1);	// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 resolve 函数接收的是 Promise 对象时，后面的 then 会根据传递的 Promise 对象的状态变化决定执行哪一个回调</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(p1)).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3）具有 then 方法的对象<br>当参数是具有 then 方法的对象时，会立即执行它的 then 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">	<span class="title function_">then</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">		<span class="comment">// reject(&#x27;reason&#x27;);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable).<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data),</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable));</span><br></pre></td></tr></table></figure>

<p><strong>Promise.reject()</strong></p>
<ul>
<li>失败状态 Promise 的一种简写形式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数</li>
</ul>
<p>不管什么参数，都会原封不动地向后传递，作为后续方法的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Promise 对象为例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;我执行了&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(p1).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, rejcet</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// return data;</span></span><br><span class="line">		<span class="comment">// return Promise.resolve(data);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Promise.all()</strong></p>
<p>作用：<br>Promise.all() 关注多个 Promise 对象的状态变化<br>传入多个 Promise 实例，包装成一个新的 Promise 实例返回<br>基本用法：<br>Promise.all() 的状态变化与所有传入的 Promise 实例对象状态有关<br>所有状态都变成 resolved，最终的状态才会变成 resolved<br>只要有一个变成 rejected，最终的状态就变成 rejected</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = ms =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return &#x27;p1&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span>;</span><br><span class="line">	<span class="comment">// return Promise.reject(&#x27;reason&#x27;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]);</span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Promise.race()</strong></p>
<p>Promise.race() 的状态取决于第一个完成的 Promise 实例对象，如果第一个完成的成功了，那最终的就成功；如果第一个完成的失败了，那最终的就失败</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = ms =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line">	<span class="comment">// return Promise.reject(&#x27;reason&#x27;);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return &#x27;p2&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> racePromise = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2]);</span><br><span class="line">racePromise.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Promise.allSettled()</strong></p>
<p>Promise.allSettled() 的状态与传入的Promise 状态无关，永远都是成功的<br> 它只会忠实的记录下各个 Promise 的表现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = ms =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span>;</span><br><span class="line">	<span class="comment">// return Promise.reject(&#x27;reason&#x27;);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 完成了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return &#x27;p2&#x27;;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2]);</span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;succ&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Promise-的注意事项和应用"><a href="#Promise-的注意事项和应用" class="headerlink" title="Promise 的注意事项和应用"></a>Promise 的注意事项和应用</h5><p><strong>resolve 或 reject 函数执行后的代码</strong><br>推荐在调用 resolve 或 reject 函数的时候加上 return，不再执行它们后面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// return resolve(123);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Promise.all / race / allSettled 的参数问题</strong><br>参数如果不是 Promise 数组，会将不是 Promise 的数组元素转变成 Promise 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).<span class="title function_">then</span>(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(datas);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">	<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(datas);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>不只是数组，任何可遍历的都可以作为参数<br>数组、字符串、Set、Map、NodeList、arguments</p>
<pre><code>// 以 Set 为例
Promise.all(new Set([1, 2, 3])).then(datas =&gt; &#123;
    console.log(datas);
&#125;);
</code></pre>
<p><strong>Promise.all / race / allSettled 的错误处理</strong></p>
<p>错误既可以单独处理，也可以统一处理<br>一旦被处理，就不会在其他地方再处理一遍</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = ms =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">delay</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1 完成了&#x27;</span>);</span><br><span class="line"><span class="comment">// return &#x27;p1&#x27;;</span></span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reason&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 	.catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//  	 console.log(&#x27;p1&#x27;, err);</span></span><br><span class="line"><span class="comment">// 	&#125;);</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">delay</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2 完成了&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span>;</span><br><span class="line"><span class="comment">// return Promise.reject(&#x27;reason&#x27;);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 	.catch(err =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   	console.log(&#x27;p2&#x27;, err);</span></span><br><span class="line"><span class="comment">// 	&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allPromise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2]);</span><br><span class="line">allPromise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(datas);</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>函数是ES6提供的一种异步编程解决方案，Generator函数是一个状态机，封装了多个内部状态，可暂停函数，yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。优点是异步语义清晰，缺点是手动迭代Generator函数很麻烦，实现逻辑优点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>; <span class="comment">//将状态一的返回值赋值给res变量, 注意：拿到的不是yield后面的状态描述</span></span><br><span class="line">  <span class="comment">// 我们想要在第二个状态使用第一个状态得返回值,直接使用是获取不到得</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="string">&#x27;获取res&#x27;</span>); <span class="comment">//100 &#x27;获取res&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">test</span>(); <span class="comment">//返回值 返回的是一个迭代器对象/generator对象</span></span><br><span class="line">res.<span class="title function_">next</span>(); <span class="comment">//发起第一个状态的执行</span></span><br><span class="line">res.<span class="title function_">next</span>(<span class="number">100</span>);<span class="comment">// 如果想要在第二个状态拿第一个状态得返回值,就需要在第二个状态执行得时候传递参数</span></span><br></pre></td></tr></table></figure>

<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>是于Promise实现的，async/awt使得异步代码看起来像同步代码，所以优点是使用方法清晰明了，缺点是await将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了await会导致性能上的降低，代码没有依赖性的话，完全可以使用Promise.all的方式。</p>
<h3 id="Symbol-bigInt"><a href="#Symbol-bigInt" class="headerlink" title="Symbol\bigInt"></a>Symbol\bigInt</h3><p><code>Symbol</code>是<code>ES6</code>中新增的一种基本数据类型，它是一个函数，会返回一个<code>Symbol</code>类型的值，每一个<code>Symbol</code>函数返回的值都是唯一的，它们可以被作为对象属性的标识符。</p>
<h3 id="数据结构Set和Map"><a href="#数据结构Set和Map" class="headerlink" title="数据结构Set和Map"></a>数据结构Set和Map</h3><p>Set 对象(集合)类似于数组，且成员的值都是唯一的（通俗的理解：不能出现相同的元素）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可不传数组</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">set1.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">set1.<span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set1) <span class="comment">// Set(2) &#123; 1, 2 &#125;</span></span><br><span class="line"><span class="comment">// 也可传数组</span></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 增加元素 使用 add</span></span><br><span class="line">set2.<span class="title function_">add</span>(<span class="number">4</span>)</span><br><span class="line">set2.<span class="title function_">add</span>(<span class="string">&#x27;林三心&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2) <span class="comment">// Set(5) &#123; 1, 2, 3, 4, &#x27;林三心&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 是否含有某个元素 使用 has</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2.<span class="title function_">has</span>(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查看长度 使用 size</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2.<span class="property">size</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 删除元素 使用 delete</span></span><br><span class="line">set2.<span class="title function_">delete</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2) <span class="comment">// Set(4) &#123; 1, 3, 4, &#x27;林三心&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 两个对象都是不同的指针，所以没法去重</span></span><br><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;, <span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set1) <span class="comment">// Set(4) &#123; 1, &#123; name: &#x27;林三心&#x27; &#125;, 2, &#123; name: &#x27;林三心&#x27; &#125; &#125;</span></span><br><span class="line"><span class="comment">// 如果是两个对象是同一指针，则能去重</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;林三心&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, obj, <span class="number">2</span>, obj])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set2) <span class="comment">// Set(3) &#123; 1, &#123; name: &#x27;林三心&#x27; &#125;, 2 &#125;</span></span><br><span class="line"><span class="comment">//咱们都知道 NaN !== NaN，NaN是自身不等于自身的，但是在Set中他还是会被去重</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="title class_">NaN</span>, <span class="number">1</span>, <span class="title class_">NaN</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set) <span class="comment">// Set(2) &#123; 1, NaN &#125;</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// Set可利用扩展运算符转为数组哦</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">// [1,  2, 3, 4, 5, 66, 9]</span></span><br></pre></td></tr></table></figure>

<p>Map 是一组键值对的结构，和 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=js%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">js对象</a>类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化`Map`需要一个二维数组(请看 Map 数据结构)，或者直接初始化一个空`Map` </span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//添加key和value值</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;Amy&#x27;</span>,<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;liuQi&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="comment">//是否存在key，存在返回true,反之为false</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;Amy&#x27;</span>) <span class="comment">//true</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;amy&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"><span class="comment">//根据key获取value</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;Amy&#x27;</span>) <span class="comment">//女</span></span><br><span class="line"><span class="comment">//删除 key为Amy的value</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;Amy&#x27;</span>)</span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;Amy&#x27;</span>) <span class="comment">//undefined  删除成功</span></span><br><span class="line"><span class="comment">// 定义map</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="comment">// 新增键值对 使用 set(key, value)</span></span><br><span class="line">map1.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">map1.<span class="title function_">set</span>(<span class="string">&#x27;哈哈&#x27;</span>, <span class="string">&#x27;嘻嘻嘻&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1) <span class="comment">// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#x27;哈哈&#x27; =&gt; &#x27;嘻嘻嘻&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 判断map是否含有某个key 使用 has(key)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">has</span>(<span class="string">&#x27;哈哈&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取map中某个key对应的value 使用 get(key)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1.<span class="title function_">get</span>(<span class="literal">true</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 删除map中某个键值对 使用 delete(key)</span></span><br><span class="line">map1.<span class="title function_">delete</span>(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1) <span class="comment">// Map(2) &#123; true =&gt; 1, 1 =&gt; 2 &#125;</span></span><br><span class="line"><span class="comment">// 定义map，也可传入键值对数组集合</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="literal">true</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;哈哈&#x27;</span>, <span class="string">&#x27;嘻嘻嘻&#x27;</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2) <span class="comment">// Map(3) &#123; true =&gt; 1, 1 =&gt; 2, &#x27;哈哈&#x27; =&gt; &#x27;嘻嘻嘻&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="class定义类"><a href="#class定义类" class="headerlink" title="class定义类"></a>class定义类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 类的构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_address</span> = <span class="string">&#x27;北京市&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    eating () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; 正在eating~&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    running () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; 正在running~&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;jam&#x27;</span>, <span class="number">19</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line">p1.<span class="title function_">eating</span>()</span><br><span class="line">p1.<span class="title function_">running</span>()</span><br></pre></td></tr></table></figure>

<h3 id="reflect对象"><a href="#reflect对象" class="headerlink" title="reflect对象"></a>reflect对象</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reflect.defineProperty会返回false来代表此次操作失败</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;鲨鱼辣椒&#x27;</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>) <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">&#125;)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;鲨鱼辣椒&#x27;</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 鲨鱼辣椒</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">// 鲨鱼辣椒</span></span><br></pre></td></tr></table></figure>

<p>Proxy可以最大限度的弥补Object.defineProperty带来的缺点，而Proxy也不仅仅只能代理对象，还可以代理数组等其它对象。代理可以捕获13种不同的操作，而每种操作都会有一个所对应的ReflectApi，这就使Proxy对象可以方便的调用对应的Reflect方法来完成默认行为。我们前面已经对Proxy与Reflect进行了讲解，现在就让它们结合起来吧</p>
<h3 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h3><p>var ——ES5 变量声明方式变量未赋值时，变量undefined（为使用声明变量时也为undefined）<br>作用域——var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用</p>
<p>let——ES6变量声明方式<br>在变量为声明前直接使用会报错<br>作用域——let为块作用域——通常let比var 范围要小<br>let禁止重复声明变量，否则会报错；var可以重复声明</p>
<p>const——ES6变量声明方式</p>
<ol>
<li>const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改该常量的值</li>
<li>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动</li>
</ol>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>
<p>暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 报错 因为本区域有tmp声明变量</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// 绑定if这个块级的作用域 不能出现tmp变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p><strong>概念</strong>：多个作用域对象连续引用形成的链式结构。</p>
<p><strong>使用方面解释</strong>：当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域，如果在全局作用域里仍然找不到该变量，它就会直接报错。</p>
<p><strong>存储方面解释</strong>：作用域链在JS内部中是以数组的形式存储的，数组的第一个索引对应的是函数本身的执行期上下文，也就是当前执行的代码所在环境的变量对象，下一个索引对应的空间存储的是该对象的外部执行环境，依次类推，一直到全局执行环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">200</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//100</span></span><br><span class="line"><span class="comment">// fun函数局部作用域中没有变量a，于是从它的上一级，也就是全局作用域中找，</span></span><br><span class="line"><span class="comment">//在全局中a被赋值为100，于是输出100</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)<span class="comment">//200 fun函数局部作用域中有变量b，并且它被赋值为了200，输出200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">f</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line">   (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">f</span>()   <span class="comment">//10，而不是20; 函数的作用域是在函数定义的时候就被决定了，与函数在哪里被调用无关</span></span><br><span class="line">   &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fun)</span><br></pre></td></tr></table></figure>

<p>由于变量的查找是沿着作用域链来实现的，所以也称作用域链为变量查找的机制。是不是很好理解，这里再来补充一点作用域的作用</p>
<ul>
<li>作用域最为重要的一点是安全。变量只能在特定的区域内才能被访问，外部环境不能访问内部环境的任何变量和函数，即可以向上搜索，但不可以向下搜索， 有了作用域我们就可以避免在程序其它位置意外对某个变量做出修改导致程序发生事故。</li>
<li>作用域能够减轻命名的压力。我们可以在不同的作用域内定义相同的变量名，并且这些变量名不会产生冲突。。</li>
</ul>
<h4 id="为什么let在编译后实际还是var？"><a href="#为什么let在编译后实际还是var？" class="headerlink" title="为什么let在编译后实际还是var？"></a>为什么let在编译后实际还是var？</h4><p><strong>原因：</strong></p>
<ol>
<li>let 和 const 是 ES6 新增的变量申明关键字， 和 var 的主要区别在于作用域的不同，var 支持全局作用域和函数作用域，而 let 和 const 是块作用域。Babel 使用 babel-plugin-transform-block-scoping 插件完成 let 到 var 的转换，本质是块作用域到函数作用域或全局作用域的转换。</li>
<li>Babel 在生成 AST 之后，定义了一个访问者（visitor），用于遍历 AST 的过程中，根据语法规则生成作用域对象(Scope)，该对象中定义了该作用域下绑定的变量，这些变量是否被引用以及每个引用具体的路径。这些信息是后续修改作用域以及变量更换绑定的基础。</li>
<li>let 直接变为 var 很容易导致语义变化，需要结合作用域和上下文来进行判断，如果变成 var 后，和同层作用域的变量名称发生冲突，可以修改名称解决。如果 let 被内层作用域的方法引用，则需要修改代码，形成闭包。</li>
<li>babel-plugin-transform-block-scoping 插件是 Babel 中负责块级作用域转换的插件，实现了收集作用域下变量，判断是否存在闭包，let 节点修改等功能。我们在自己编写插件的时候，最好能多看几个 Babel 的原生插件，不仅可以了解 Babel 编译的原理，还可以学一些 AST 操作的方法。</li>
</ol>
<p><strong>如何变化</strong></p>
<ol>
<li>let 处于全局作用域，那么 let 直接变成 var。</li>
<li>let 处于块作用域，那就要判断该变量升级至上级的函数作用域或者全局作用域后，是否会与同一作用域的变量发生重名现象，如果重名，那就换个变量名。同时修改所有引用这个变量的代码。</li>
<li>let 处于循环语句中，形成类似闭包的效果，此时需要将循环内部的方法转换为立即执行函数的写法，利用闭包的特性保存循环次数。</li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>可以看出，定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了function关键字，采用箭头=&gt;来定义函数。</p>
<p>关于箭头函数的参数：① 如果箭头函数没有参数，直接写一个空括号即可。② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。</p>
<p>① 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p>
<p>② 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写</p>
<p>③ 如果箭头函数的函数体只有一条语句并且不需要返回值（最常见是调用一个函数），可以给这条语句前面加一个void关键字</p>
<p>区别：</p>
<ul>
<li>语法更加简洁、清晰。箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷。</li>
<li>箭头函数不会创建自己的this。箭头函数没有自己的this，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。</li>
<li>箭头函数继承而来的this指向永远不变。call()/.apply()/.bind()无法改变箭头函数中this的指向.call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。</li>
<li>箭头函数不能作为构造函数使用。因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，</li>
<li>箭头函数没有自己的arguments</li>
<li>箭头函数没有原型prototype</li>
<li>箭头函数不能用作Generator函数，不能使用yeild关键字</li>
</ul>
<h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><ol>
<li>创建一个空对象</li>
<li>this指向这个对象</li>
<li>执行构造函数的语句</li>
<li>返回该对象</li>
</ol>
<h2 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>将父类的实例作为子类的原型</p>
<p>优点</p>
<ul>
<li>父类方法可以复用<br>缺点</li>
<li>父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</li>
<li>子类型实例不能给父类型构造函数传参</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">isShow</span> = <span class="literal">true</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">info</span> = &#123;</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getInfo</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">info</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">isShow</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Child1</span> = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="title class_">Child1</span>.<span class="property">info</span>.<span class="property">gender</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="title class_">Child1</span>.<span class="title function_">getInfo</span>();  <span class="comment">// &#123;name: &quot;yhd&quot;, age: 18, gender: &quot;男&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child2.<span class="title function_">getInfo</span>();  <span class="comment">// &#123;name: &quot;yhd&quot;, age: 18, gender: &quot;男&quot;&#125;</span></span><br><span class="line">child2.<span class="property">isShow</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">isShow</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h3><ul>
<li>先定义一个父构造函数(this指向为window)</li>
<li>再定义一个子构造函数(this指向为new出的实例化对象)</li>
<li>子构造函数通过call()改变父的this指向继承父构造函数属性</li>
</ul>
<p>优点</p>
<ul>
<li><p>可以在子类构造函数中向父类传参数</p>
</li>
<li><p>父类的引用属性不会被共享<br>缺点</p>
</li>
<li><p>不能继承原型属性，无法实现函数复用，所有方法都只能放在构造函数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">info</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child1.<span class="property">info</span>.<span class="property">gender</span> = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">info</span>); <span class="comment">// &#123;name: &quot;yhd&quot;, age: 19, gender: &quot;男&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">info</span>); <span class="comment">// &#123;name: &quot;yhd&quot;, age: 19&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承综合了<strong>原型链继承</strong>和<strong>盗用构造函数继承</strong>(构造函数继承)，将两者的优点结合了起来，</p>
<p>基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="comment">// 继承父类属性</span></span><br><span class="line">   <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类方法</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yhd&quot;</span>, <span class="number">19</span>);</span><br><span class="line">child1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;pink&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">colors</span>); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span></span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 19</span></span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;yhd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;wxb&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">colors</span>);  <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]</span></span><br><span class="line">child2.<span class="title function_">sayAge</span>(); <span class="comment">// 30</span></span><br><span class="line">child2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;wxb&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，Parent构造函数定义了name，colors两个属性，接着又在他的原型上添加了个sayName()方法。Child构造函数内部调用了Parent构造函数，同时传入了name参数，同时Child.prototype也被赋值为Parent实例，然后又在他的原型上添加了个sayAge()方法。这样就可以创建 child1，child2两个实例，让这两个实例都有自己的属性，包括colors，同时还共享了父类的sayName方法</p>
<p>优点</p>
<ul>
<li>父类的方法可以复用</li>
<li>可以在Child构造函数中向Parent构造函数中传参</li>
<li>父类构造函数中的引用属性不会被共享</li>
</ul>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>对参数对象的一种浅复制</p>
<p>优点：</p>
<ul>
<li>父类方法可复用<br>缺点：</li>
<li>父类的引用会被所有子类所共享</li>
<li>子类实例不能向父类传参</li>
<li>ES5的Object.create()方法在只有第一个参数时，与这里的objectCopy()方法效果相同</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的objectCopy可以改用 ES5 里面的 Object.create 方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;rose&quot;</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;wxb&quot;</span>;</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// wxb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;gsr&quot;</span>;</span><br><span class="line">person2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;gsr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;lily&quot;, &quot;kobe&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p>
<p>虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。</p>
<p><strong>设计模式：装饰器模式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">objectCopy</span>(original);</span><br><span class="line">  clone.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&quot;yhd&quot;</span>,</span><br><span class="line">     <span class="attr">friends</span>: [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>);</span><br><span class="line">person1.<span class="title function_">getName</span>(); <span class="comment">// yhd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;lily&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>寄生式继承+组合继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">objectCopy</span>(parent.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 创建对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//上一句可以用Object.create来代替</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = child; <span class="comment">// 增强对象</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;lily&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yhd&quot;</span>, <span class="number">23</span>);</span><br><span class="line">child1.<span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br><span class="line">child1.<span class="title function_">sayName</span>(); <span class="comment">// yhd</span></span><br><span class="line">child1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;, &quot;jack&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;yl&quot;</span>, <span class="number">22</span>)</span><br><span class="line">child2.<span class="title function_">sayAge</span>(); <span class="comment">// 22</span></span><br><span class="line">child2.<span class="title function_">sayName</span>(); <span class="comment">// yl</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;]</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>Child可以向Parent传参</li>
<li>父类方法可以复用</li>
<li>父类的引用属性不会被共享</li>
</ul>
<p>寄生式组合继承可以算是引用类型继承的最佳模式</p>
<h3 id="ES6-的-extends-关键字"><a href="#ES6-的-extends-关键字" class="headerlink" title="ES6 的 extends 关键字"></a>ES6 的 extends 关键字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> juiceice = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;juiceice&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">juiceice.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>对象里的属性分为两种：数据属性 和 访问器属性。首先我们看看数据属性。</p>
<p><strong>数据属性</strong></p>
<ol>
<li>[[<strong>Configurable</strong>]]：翻译：adj. 可配置的；结构的 表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特 性都是 true，如前面的例子所示。</li>
<li>[[<strong>Enumerable</strong>]]：翻译：adj. 可列举的；可点数的 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true，如前面的例子所示。</li>
<li>[[<strong>Writable</strong>]]：翻译：adj. 可写的，能写成文的 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的 这个特性都是 true，如前面的例子所示。</li>
<li>[[<strong>Value</strong>]]：翻译：值 包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性 的默认值为 undefined</li>
</ol>
<p><strong>访问器属性</strong></p>
<ol>
<li>[[<strong>Configurable</strong>]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[<strong>Enumerable</strong>]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对 象上的属性的这个特性都是 true。</li>
<li>[[<strong>Get</strong>]]：获取函数，在读取属性时调用。默认值为 undefined。</li>
<li>[[<strong>Set</strong>]]：设置函数，在写入属性时调用。默认值为 undefined。</li>
</ol>
<h2 id="js事件流"><a href="#js事件流" class="headerlink" title="js事件流"></a>js事件流</h2><p>事件流一共由三个阶段分别是<br>1.捕获阶段<br>2.目标阶段<br>3.冒泡阶段</p>
<p>通俗一点来说就是一个事件被触发时，浏览器会自动从用户操作标签外的最上级标签逐渐向里检查是否有相同事件，如果有则触发，如果没有则继续向下检查直到用户操作的标签，这过程称为捕获，此时浏览器会继续由用户操作标签继续向上级标签检查，如果有相同事件则触发，如果没有则继续向上检查直到最上级元素为止，此过程称为冒泡。</p>
<p>从外向内找监听函数，叫做事件捕捉<br>从内向外找监听函数，叫做事件冒泡</p>
<p><strong>取消冒泡 e.stopPropagation()</strong><br>捕获是不可取消的，但是冒泡可以取消。所有冒泡皆可取消，默认动作有的可以取消有的不能取消。e.stopPropagation() 可以中断冒泡，浏览器不再向上走了。</p>
<p>事件委托<br>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，click事件的监听函数定义在节点，但是实际上，它处理的是子节点的click事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</p>
<p><strong>优点</strong><br>省监听数（内存）<br>可以监听动态元素</p>
<h2 id="js的事件循环"><a href="#js的事件循环" class="headerlink" title="js的事件循环"></a>js的事件循环</h2><p><img src="https://zyhxwing.gitee.io/images/JavaScript/1363_1.png" alt="js事件循环"></p>
<p><strong>js事件循环</strong></p>
<p>S是单线程的，但是我们在写代码的时候，会有同步执行的代码和异步执行的代码。EventLoop就是一种解决异步回调的一种机制。具体的解决办法就是使用一个执行栈和事件队列，事件队列又分为宏任务队列和微任务队列。简单的来讲，就是把代码从上到下，会把同步任务压入到执行栈，遇到异步的任务，根据异步任务的类型，放入不同的事件队列，交给其它线程进行处理。如果执行栈空的话，就从事件队列当中取出结果，放入到执行栈中执行并执行。Event Loop 的每一次循环称为一个tick，具体是先拿出一个宏任务，然后检查它里面的微任务，如果有的话，就执行所有的微任务，结束之后，进行一次渲染。再拿出一个宏任务，按照刚刚的过程继续进行</p>
<h3 id="宏任务MacroTask"><a href="#宏任务MacroTask" class="headerlink" title="宏任务MacroTask"></a>宏任务MacroTask</h3><p>script代码、settimeout、promise、async、setInterval、ajax、dom监听、UI Rendering</p>
<h3 id="微任务MicroTask"><a href="#微任务MicroTask" class="headerlink" title="微任务MicroTask"></a>微任务MicroTask</h3><p>promise的回调函数（then、catch、finally）、await、queueMicrotask、MutationObserver的Api</p>
<h3 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h3><p>与此同时，针对于vue的mvvn框架，在修改数据之后，视图并不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。<br>Vue.nextTick将回调函数放到微任务或者宏任务当中以延迟它地执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.<span class="property">message</span> = <span class="string">&#x27;changed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">// 并不会得到&#x27;changed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function()&#123;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//可以得到&#x27;changed&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="settimeout倒计时为什么会出现误差"><a href="#settimeout倒计时为什么会出现误差" class="headerlink" title="settimeout倒计时为什么会出现误差"></a>settimeout倒计时为什么会出现误差</h3><p>setTimeout作为异步任务，在实现倒计时功能的时候，除了执行我们功能的实现代码，还会有主线程对任务队列的读取及执行等过程，这些过程也需要耗费一些时间，所以会因为event loop的机制出现些许误差。</p>
<h3 id="为什么使用setTimeout实现倒计时，而不是setInterval"><a href="#为什么使用setTimeout实现倒计时，而不是setInterval" class="headerlink" title="为什么使用setTimeout实现倒计时，而不是setInterval?"></a>为什么使用setTimeout实现倒计时，而不是setInterval?</h3><p>setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。<br>为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。</p>
<h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.</p>
<ul>
<li>监视 DOM 变动的接口<br>当监视的 DOM 发生变动时 MutationObserver 将收到通知并触发事先设定好的回调函数。</li>
<li>类似于事件，但是异步触发<br>添加监视时，MutationObserver 上的 observer 函数与 addEventListener 有相似之处，但不同于后者的同步触发，MutationObserver 是异步触发，此举是为了避免 DOM 频繁变动导致回调函数被频繁调用，造成浏览器卡顿。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br></pre></td></tr></table></figure>

<h3 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h3><p>queueMicrotask()的作用是创建一个微任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数的内容</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">queueMicrotask</span>(fn)</span><br><span class="line"><span class="comment">//等同于Promise.resolve().then(fn);</span></span><br></pre></td></tr></table></figure>

<p>效果和使用Promise一样的，都是将任务加入微任务队列<br>待宏任务结束后依次执行</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。requestAnimationFrame(rAF) 需要传入一个回调函数作为参数，同时该回调函数会在浏览器下一次重绘之前执行。</p>
<p>requestAnimationFrame(rAF) 的回调有两个特征：<br>在重新渲染前调用。<br>很可能在宏任务之后不调用。</p>
<p>我们来分析一下，为什么要在重新渲染前去调用？因为 rAF 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。<br>rAF在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个结果是非常不可控的，如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">req</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  i--</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">req</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">req</span>()</span><br><span class="line"><span class="comment">//浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，</span></span><br></pre></td></tr></table></figure>

<h2 id="异步网络请求xhr、ajax、fetch与axios"><a href="#异步网络请求xhr、ajax、fetch与axios" class="headerlink" title="异步网络请求xhr、ajax、fetch与axios"></a>异步网络请求xhr、ajax、fetch与axios</h2><p>现代浏览器，最开始与服务器交换数据，都是通过 XMLHttpRequest 对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123; <span class="comment">// model browser</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">ActiveXObject</span>) &#123; <span class="comment">// IE 6 and older</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>)</span><br><span class="line">&#125;<span class="comment">//创建xhr对象</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>)<span class="comment">//调用xhr.open()函数</span></span><br><span class="line"><span class="comment">//设置Content-Type属性</span></span><br><span class="line">xhr.<span class="title function_">send</span>(data)<span class="comment">//调用xhr.send()函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//监听xhr.onreadStatechange()事件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求正常</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理响应</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求遇到一些问题，处理异常</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 还处于未准备好的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 通信错误的事件中（例如服务器宕机）</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Caught Exception: &#x27;</span> + e.<span class="property">description</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>不重新加载页面的情况下更新网页<br>在页面已加载后从服务器请求/接收数据<br>在后台向服务器发送数据。<br>缺点：</p>
<p>使用起来也比较繁琐，需要设置很多值。<br>早期的IE浏览器有自己的实现，这样需要写兼容代码。</p>
<p>xhr的readyState，状态码<br>0 对象被创建但没有使用open方法<br>1 open方法已经被调用<br>2 send方法已经被调用<br>3 数据接受，response属性已经包含部分数据<br>4 ajax请求完成</p>
<ol>
<li><p>jQuery ajax<br>为了更快捷的操作 DOM，并且规避一些浏览器兼容问题，产生了 jQuery 。它里面的 AJAX 请求也兼容了各浏览器，可以有简单易用的方法 $.get, $.post 。简单点说，就是对 XMLHttpRequest 对象的封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: url, </span><br><span class="line">  <span class="attr">data</span>: data,</span><br><span class="line">  <span class="attr">dataType</span>: dataType,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：<br>XHR JSONP<br>缺点：<br>如果有多个请求，并且有依赖关系的话，容易形成回调地狱。<br>本身是针对MVC的编程，不符合现在前端MVVM的浪潮。<br>ajax是jQuery中的一个方法。如果只是要使用ajax却要引入整个jQuery非常的不合理。</p>
</li>
<li><p>fetch<br>Fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>
</li>
</ol>
<p>fetch 是底层API，代替 XHR ，可以轻松处理各种格式，非文本化格式。可以很容易的被其他技术使用，例如 Service Workers 。但是想要很好的使用 fetch ，需要做一些封装处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>优点：跨域的处理</p>
<p>在配置中，添加mode： ‘no-cors’就可以跨域了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/users.json&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>, </span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;no-cors&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* handle response */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>fetch 只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理<br>fetch 默认不会带 cookie ，需要添加配置项。<br>fetch 不支持 abort ，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。<br>fetch 没有办法原生监测请求的进度，而 XHR 可以。<br>请注意， fetch 规范与 jQuery.ajax() 主要有三点不同，牢记：</p>
<p>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject ， 即使该 HTTP 响应的状态码是 404 或 500 。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject 。<br>fetch() 不会接受跨域 cookies ；你也不能使用 fetch() 建立起跨域会话。其他网站的 Set-Cookie 头部字段将会被无视。<br>fetch 不会发送 cookies 。除非你使用了 credentials 的 初始化选项。（自2017年8月25日以后，默认的 credentials 策略变更为 same-origin 。Firefox也在61.0b13版本中，对默认值进行修改）<br>\4. axios<br>axios 是一个基于 promise 的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生 XMLHttpRequest 的封装，只不过它是 Promise 的实现版本，符合最新的ES规范。</p>
<p>这是官方的并发案例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(),<span class="title function_">getUserPermissions</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span> (<span class="params">acct, perms</span>) &#123;</span><br><span class="line">    <span class="comment">// Both requests are now complete</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>

<p>axios是尤雨溪大神推荐使用的,</p>
<p>优点：</p>
<p>XMLHttpRequests<br>node.js<br>Promise API<br>JSON<br>XSRF<br>缺点：</p>
<p>只持现代浏览器</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>javascript和typescript的区别是什么</p>
<p>区别：<br>1、TypeScript中的数据要求带有明确的类型，JavaScript不要求。<br>2、TypeScript引入了JavaScript中没有的“类”概念。<br>3、TypeScript通过类型注解提供编译时的静态类型检查（ 虽然JavaScript是弱类型语言，但是在将其升级改造引入”类型注解”这一概念后的TypeScript中，类型注解相当于强类型语言中声明了某个变量的类型，以后该变量就必须为此类型，否则ts编译器将报错，并不能正确地编译成js文件。）。</p>
<h2 id="JS的arugments"><a href="#JS的arugments" class="headerlink" title="JS的arugments"></a>JS的arugments</h2><p>在函数调用的时候，浏览器每次都会传递进两个隐式参数：<br>一个是函数的上下文对象this，另一个则是封装实参的类数组对象arguments。</p>
<p>1、arguments是一个类数组对象，用来存储实参；具有length、callee等属性；可以用arguments[0]这个形式访问实参；可以转换为真实数组。<br>2、arguments和函数相关联，其只有在函数执行时可用，不能显式创建。<br>3、arguments可以用来遍历参数；通过callee实现递归；也可以模拟函数重载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 可以使用slice来将arguments转换为真实数组</span></span><br><span class="line">    <span class="keyword">var</span> args1 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> args2 = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">// 也可以使用Array.from()方法或者扩展运算符来将arguments转换为真实数组</span></span><br><span class="line">    <span class="keyword">var</span> args3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> args4 = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f5</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JS的原型链"><a href="#JS的原型链" class="headerlink" title="JS的原型链"></a>JS的原型链</h2><p>什么是原型：任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。</p>
<p>什么是原型链：<strong>原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__中查找，也就是构造函数的显式原型prototype中查找，如果构造函数的显式原型prototype中也没有该属性，因为构造函数的显式原型prototype也是对象，也有__proto__，那么会去它的__proto__指向的另一个显式原型prototype中查找，一直到null，如果没有则返回undefined</p>
<ul>
<li>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型)</li>
<li>所有函数除了有_proto_属性之外还拥有prototype属性（显式原型）</li>
</ul>
<h2 id="JS-set、map、weakset、weakmap区别"><a href="#JS-set、map、weakset、weakmap区别" class="headerlink" title="JS set、map、weakset、weakmap区别"></a>JS set、map、weakset、weakmap区别</h2><p>共同点：<br>他们都是构造函数</p>
<p>不同点：<br>1、weakset、set不允许有重复的数据，set可以存储原始值和对象引用，存储的数据必须是唯一值<br>2、weakset是弱集合，存储的数据只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>3、map表示字典，用键值对的形式存放数据，键和值可以是原始值和对象引用<br>4、weakmap是弱字典，以键值对形式存放，键只能是对象，对对象的引用是弱引用；在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收；不可枚举<br>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的；所以不容易造成内存泄漏。</p>
<h2 id="js-垃圾回收机制"><a href="#js-垃圾回收机制" class="headerlink" title="js 垃圾回收机制"></a>js 垃圾回收机制</h2><p>我们知道，程序运行中会有一些垃圾数据不再使用，需要及时释放出去，如果我们没有及时释放，这就是内存泄露。JavaScript 是一门具有自动垃圾收集机制的编程语言，由执行环境负责在代码执行时管理内存。JS 中的垃圾数据都是由垃圾回收（Garbage Collection，缩写为 GC）器自动回收的，不需要手动释放。JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可。</p>
<p>常见的垃圾回收方法：1）引用计数方法；2）标记清除方法。</p>
<p><strong>1）引用计数</strong><br>引用计数就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加一，反之解除时就减一，当该对象引用计数为 0 时就会被回收。如果出现循环引用，则一直不会被回收，还是会造成内存泄漏。</p>
<p>解决办法：及时销毁绑定的事件、使用弱引用 weakMap、weakSet。</p>
<p><strong>2）标记清除方法。</strong></p>
<p>V8 中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：<br>标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。<br>清除：将所有垃圾数据清理掉。</p>
<p><img src="https://zyhxwing.gitee.io/images/JavaScript/1365_1.png" alt="标记清除方法"></p>
<p><strong>标记清除方法</strong></p>
<p>垃圾回收算法垃圾回收的实现简单分为以下三个步骤：<br><strong>1）可访问性</strong><br>从 GC Roots 对象出发，遍历 GC Root 中的所有对象：<br>a、可访问对象：通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留。<br>b、不可访问对象：通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），并会对其做上标记，那么这些不可访问的对象就可能被回收。</p>
<p>GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：全局的 window 对象（位于每个 iframe 中）；文档 DOM 树，可以通过遍历文档到达的所有原生 DOM 节点组成；存放栈上变量。</p>
<p><strong>2）回收不可访问对象所占据的内存</strong><br>在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p><strong>3）内存整理</strong><br>频繁回收对象后，内存中就会存在大量不连续空间，称为内存碎片。当出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就会出现内存不足的情况，所以最后一步需要整理这些内存碎片。</p>
<p>在我们的实际开发过程中，如果我们想要让垃圾回收器回收某一对象，就将对象的引用直接设置为 null。但如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 null 时，该对象是不会被回收的，依然存在。</p>
<h2 id="Cookie、LocalStorage、SessionStorage"><a href="#Cookie、LocalStorage、SessionStorage" class="headerlink" title="Cookie、LocalStorage、SessionStorage"></a>Cookie、LocalStorage、SessionStorage</h2><p><img src="https://zyhxwing.gitee.io/images/JavaScript/1367_1.png" alt="Cookie、LocalStorage、SessionStorage"></p>
<p><strong>Cookie、LocalStorage、SessionStorage</strong></p>
<h3 id="cookies属性有哪些"><a href="#cookies属性有哪些" class="headerlink" title="cookies属性有哪些"></a>cookies属性有哪些</h3><ul>
<li>cookieName=cookieValue 设置 cookie 的名字和值，必填项。</li>
<li>HttpOnly 只能通过 HTTP 响应报文的 Set-Cookie 来新增或更新 cookie ，客户端无法通过脚本的方式来读写 cookie。</li>
<li>Expires cookie 的过期时间点</li>
<li>Max-Age cookie 的有效时间长度</li>
<li>Path 设置 cookie 的路径作用域</li>
<li>Domain 设置 cookie 的 domain 作用域。</li>
<li>Secure 该属性没有值，属性本身存在就代表设置为安全模式。即请求必须为安全连接（HTTPS），cookie 才会被保存下来。HTTP 协议下，cookie 无效。</li>
<li>SameSite cookie 在跨域时是否应该被发送。</li>
</ul>
<h2 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h2><p>闭包是指有权访问另外一个函数作用域中的变量的函数。<br>内部的函数存在外部作用域的引用就会导致闭包。</p>
<p>闭包中的变量存储的位置是堆内存。</p>
<p><strong>作用：</strong><br>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化。局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。</p>
<p><strong>闭包使用场景</strong><br>return一个函数<br>函数作为参数<br>循环赋值<br>防抖节流</p>
<p><strong>闭包缺点</strong><br>容易导致内存泄漏。闭包会携带包含它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多</p>
<h2 id="js内存泄漏"><a href="#js内存泄漏" class="headerlink" title="js内存泄漏"></a>js内存泄漏</h2><h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><p>当内存中本应该在垃圾回收周期中清理的对象，因为被另一个对象的无意引用而从根能够保持可访问时，就会发生内存泄漏。将冗余对象保留在内存中会导致应用程序内部使用过多的内存，并可能导致性能下降。</p>
<h3 id="performance工具"><a href="#performance工具" class="headerlink" title="performance工具"></a>performance工具</h3><ul>
<li>打开浏览器输入目标网址</li>
<li>进入开发人员工具面板，选择性能</li>
<li>开启录制功能，访问具体界面</li>
<li>执行用户行为，一段时间后停止录制</li>
<li>分析界面中记录的内存信息</li>
</ul>
<h3 id="那该如何判断代码正在泄漏内存呢？"><a href="#那该如何判断代码正在泄漏内存呢？" class="headerlink" title="那该如何判断代码正在泄漏内存呢？"></a>那该如何判断代码正在泄漏内存呢？</h3><ul>
<li>内存使用检查最快的方法就是<strong>查看浏览器的任务管理器</strong>。 它们提供了当前在浏览器中运行的所有选项卡和进程的概览。在任务管理器中查看每个选项卡的 JavaScript 内存占用情况。如果网站什么都不做，但是 JavaScript 内存使用量却在逐渐增加，那们很有可能发生了内存泄漏。（快捷键 shift+esc）</li>
<li>timeline时序图记录（控制台 性能 记录 ）</li>
<li>堆快照查找分离DOM（控制台 内存 堆快照）</li>
<li>判断是否存在频繁的垃圾回收GC<ul>
<li>timeline中频繁的上升下降</li>
<li>任务管理器中数据频繁的增加减少</li>
</ul>
</li>
</ul>
<h3 id="什么会导致内存泄漏呢"><a href="#什么会导致内存泄漏呢" class="headerlink" title="什么会导致内存泄漏呢"></a>什么会导致内存泄漏呢</h3><ol>
<li>意外的全局变量：由于使用未声明的变量,而意外的创建了一个全局变量,而使这个变量一直留在内存中无法被回收。<strong>通过使用严格模式“use strict”来避免这一切。在JavaScript文件的开头，它将开启更严格的JavaScript解析模式，从而防止意外的创建全局变量。</strong></li>
<li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。<strong>修改计时器回调中引用的对象；必要时使用从计时器返回的句柄（定时器的标识符）取消它clearInterval()。</strong></li>
<li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。要解决此问题，<strong>可以在完成后，删除指向DOM元素的变量。</strong></li>
<li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。<strong>了解何时创建闭包以及闭包保留了哪些对象；了解闭包的预期寿命和用法（尤其是用作回调时）。</strong></li>
<li>事件监听器：事件侦听器将防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到：<strong>使用 removeEventListener() 显式删除或者关联的 DOM 元素被移除。</strong></li>
<li>缓存：如果不断地将内存添加到缓存中，而不删除未使用的对象，并且没有一些限制大小的逻辑，那么缓存可以无限增长。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user_1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Peter&quot;</span>, <span class="attr">id</span>: <span class="number">12345</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> user_2 = &#123; <span class="attr">name</span>: <span class="string">&quot;Mark&quot;</span>, <span class="attr">id</span>: <span class="number">54321</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> mapCache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cache</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (!mapCache.<span class="title function_">has</span>(obj))&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="string">`<span class="subst">$&#123;obj.name&#125;</span> has an id of <span class="subst">$&#123;obj.id&#125;</span>`</span>;</span><br><span class="line">    mapCache.<span class="title function_">set</span>(obj, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [value, <span class="string">&#x27;computed&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [mapCache.<span class="title function_">get</span>(obj), <span class="string">&#x27;cached&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cache</span>(user_1); <span class="comment">// [&#x27;Peter has an id of 12345&#x27;, &#x27;computed&#x27;]</span></span><br><span class="line"><span class="title function_">cache</span>(user_1); <span class="comment">// [&#x27;Peter has an id of 12345&#x27;, &#x27;cached&#x27;]</span></span><br><span class="line"><span class="title function_">cache</span>(user_2); <span class="comment">// [&#x27;Mark has an id of 54321&#x27;, &#x27;computed&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapCache); <span class="comment">// &#123;&#123;…&#125; =&gt; &#x27;Peter has an id of 12345&#x27;, &#123;…&#125; =&gt; &#x27;Mark has an id of 54321&#x27;&#125;</span></span><br><span class="line">user_1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapCache); <span class="comment">// &#123;&#123;…&#125; =&gt; &#x27;Peter has an id of 12345&#x27;, &#123;…&#125; =&gt; &#x27;Mark has an id of 54321&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，缓存仍然保留 user_1 对象。因此，我们需要将那些永远不会被重用的变量从缓存中清除。<strong>可以使用 WeakMap 来解决此问题。</strong>它是一种具有弱键引用的数据结构，仅接受对象作为键。如果我们使用一个对象作为键，并且它是对该对象的唯一引用——相关变量将从缓存中删除并被垃圾收集。在以下示例中，将 user_1 对象清空后，相关变量会在下一次垃圾回收后自动从 WeakMap 中删除。</p>
<h2 id="TypeScript与JavaScript区别"><a href="#TypeScript与JavaScript区别" class="headerlink" title="TypeScript与JavaScript区别"></a>TypeScript与JavaScript区别</h2><p>区别：</p>
<ol>
<li>TypeScript中的数据要求带有明确的类型，JavaScript不要求。</li>
<li>TypeScript引入了JavaScript中没有的“类”概念。</li>
<li>TypeScript通过类型注解提供编译时的静态类型检查（ 虽然JavaScript是弱类型语言，但是在将其升级改造引入”类型注解”这一概念后的TypeScript中，类型注解相当于强类型语言中声明了某个变量的类型，以后该变量就必须为此类型，否则ts编译器将报错，并不能正确地编译成js文件）。</li>
</ol>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/1/170965259fb768fd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="深拷贝和浅拷贝"></p>
<p><strong>深拷贝和浅拷贝</strong></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>
<li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li>
<li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>浅拷贝：</p>
<ul>
<li>Object.assign()</li>
<li>lodash.clone</li>
<li>展开运算符…</li>
<li>Array.prototype.concat()</li>
<li>Array.prototype.slice()<br>深拷贝：</li>
<li>JSON.parse(JSON.stringify())</li>
<li>lodash.cloneDeep</li>
<li>jQuery.extend()</li>
<li>手写递归方法</li>
</ul>
<h2 id="JSON-stringify有什么缺点？"><a href="#JSON-stringify有什么缺点？" class="headerlink" title="JSON.stringify有什么缺点？"></a>JSON.stringify有什么缺点？</h2><ol>
<li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</li>
<li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li>
<li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li>
<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li>
<li>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；<br>6、如果对象中存在循环引用的情况也无法正确实现深拷贝；</li>
</ol>
<h2 id="函数执行作用域"><a href="#函数执行作用域" class="headerlink" title="函数执行作用域"></a>函数执行作用域</h2><p>函数执行时做的事情</p>
<ol>
<li>确定作用域链： 当前执行上下文，上级执行上下文</li>
<li>确定this指向：window</li>
<li>初始化arguments对象</li>
<li>形参赋值</li>
<li>执行代码</li>
</ol>
<h2 id="js阴间面试题"><a href="#js阴间面试题" class="headerlink" title="js阴间面试题"></a>js阴间面试题</h2><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!==0.3"></a>0.1+0.2!==0.3</h3><p>原因总结：<br>进制转换 ：js 在做数字计算的时候，<strong>0.1 和 0.2 都会被转成二进制后无限循环</strong>，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。<br>对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。</p>
<p>解决办法：</p>
<ol>
<li>转为整数（大数）运算。</li>
<li>使用 Number.EPSILON 误差范围。</li>
<li>转成字符串，对字符串做加法运算。</li>
</ol>
<h3 id="后端返回一万条数据"><a href="#后端返回一万条数据" class="headerlink" title="后端返回一万条数据"></a>后端返回一万条数据</h3><ol>
<li>直接渲染</li>
<li>setTimeOut分片渲染，每次默认渲染200条</li>
<li>requestAnimationFrame，用createElement创建列表元素，减少重排次数</li>
<li>requestAnimationFrame，用document.createDocumentFragment方法创建列表元素，不会触发DOM树的重新渲染</li>
<li>在页面中加入空元素，监听空元素是否存在，当存在的时候加载下一页</li>
<li>虚拟列表</li>
</ol>
<p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519a393dee2c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="虚拟列表"></p>
<p><strong>虚拟列表</strong></p>
<p>计算当前可视区域起始数据索引(startIndex)<br>计算当前可视区域结束数据索引(endIndex)<br>计算当前可视区域的数据，并渲染到页面中<br>计算startIndex对应的数据在整个列表中的偏移位置startOffset并设置到列表上</p>
<p>上述实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。</p>
<p>可以以预估高度先行渲染，然后获取真实高度并缓存。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">happy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/29/js/">http://example.com/2023/03/29/js/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">豆豆想吃骨头</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/03/29/vue/" title="vue"><img class="cover" src="/img/%E7%89%8C%E7%89%8Cvue.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">js常见函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-number">2.1.</span> <span class="toc-text">Object.assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">2.2.</span> <span class="toc-text">Object.defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">可枚举属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-prototype"><span class="toc-number">2.4.</span> <span class="toc-text">String.prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach%E3%80%81filter%E3%80%81map%E3%80%81some%E3%80%81every%E3%80%81find%E3%80%81findIndex%E3%80%81reduce"><span class="toc-number">2.5.</span> <span class="toc-text">forEach、filter、map、some、every、find、findIndex、reduce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C-foreach"><span class="toc-number">2.5.1.</span> <span class="toc-text">批量操作 foreach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E5%BE%81%E4%BF%A1%E6%81%AFmap"><span class="toc-number">2.5.2.</span> <span class="toc-text">生成原始数据的特征信息map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E8%BF%87%E6%BB%A4filter"><span class="toc-number">2.5.3.</span> <span class="toc-text">筛选过滤filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99some"><span class="toc-number">2.5.4.</span> <span class="toc-text">判断数组中有没有符合条件的时候some</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%85%A8%E7%AC%A6%E5%90%88every"><span class="toc-number">2.5.5.</span> <span class="toc-text">判断数组元素是否全符合every</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AC%A6%E5%90%88%E7%9A%84find"><span class="toc-number">2.5.6.</span> <span class="toc-text">寻找数组元素中一个符合的find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E6%89%80%E9%9C%80%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95findIndex"><span class="toc-number">2.5.7.</span> <span class="toc-text">当需要知道所需元素的索引findIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%B4%AF%E5%8A%A0reduce"><span class="toc-number">2.5.8.</span> <span class="toc-text">递归累加reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">常见数据类型检测的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice%E3%80%81splice%E3%80%81split"><span class="toc-number">2.7.</span> <span class="toc-text">slice、splice、split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in%E3%80%81Object-keys%E5%92%8Cfor-of"><span class="toc-number">2.8.</span> <span class="toc-text">for in、Object.keys和for-of</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E3%80%81function%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">3.</span> <span class="toc-text">var、function变量、函数提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es6"><span class="toc-number">4.</span> <span class="toc-text">es6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#parseInt%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">parseInt方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">拓展运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.3.</span> <span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5Promise%E3%80%81Generator%E5%92%8CAsync"><span class="toc-number">4.4.</span> <span class="toc-text">异步Promise、Generator和Async</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise"><span class="toc-number">4.4.1.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">Promise 的实例方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">Promise 的构造函数方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">Promise 的注意事项和应用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator"><span class="toc-number">4.4.2.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await"><span class="toc-number">4.4.3.</span> <span class="toc-text">async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-bigInt"><span class="toc-number">4.5.</span> <span class="toc-text">Symbol\bigInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Set%E5%92%8CMap"><span class="toc-number">4.6.</span> <span class="toc-text">数据结构Set和Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">4.7.</span> <span class="toc-text">class定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.</span> <span class="toc-text">reflect对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let-const-var"><span class="toc-number">4.9.</span> <span class="toc-text">let const var</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">4.9.1.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">4.9.2.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88let%E5%9C%A8%E7%BC%96%E8%AF%91%E5%90%8E%E5%AE%9E%E9%99%85%E8%BF%98%E6%98%AFvar%EF%BC%9F"><span class="toc-number">4.9.3.</span> <span class="toc-text">为什么let在编译后实际还是var？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">4.10.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">new做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text">js继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">盗用构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">6.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">6.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">6.6.</span> <span class="toc-text">寄生式组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-%E7%9A%84-extends-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.7.</span> <span class="toc-text">ES6 的 extends 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">对象的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">8.</span> <span class="toc-text">js事件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.</span> <span class="toc-text">js的事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1MacroTask"><span class="toc-number">9.1.</span> <span class="toc-text">宏任务MacroTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1MicroTask"><span class="toc-number">9.2.</span> <span class="toc-text">微任务MicroTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-nextTick"><span class="toc-number">9.3.</span> <span class="toc-text">Vue.nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settimeout%E5%80%92%E8%AE%A1%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%AF%AF%E5%B7%AE"><span class="toc-number">9.4.</span> <span class="toc-text">settimeout倒计时为什么会出现误差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8setTimeout%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFsetInterval"><span class="toc-number">9.5.</span> <span class="toc-text">为什么使用setTimeout实现倒计时，而不是setInterval?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationObserver"><span class="toc-number">9.6.</span> <span class="toc-text">MutationObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queueMicrotask"><span class="toc-number">9.7.</span> <span class="toc-text">queueMicrotask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requestAnimationFrame"><span class="toc-number">10.</span> <span class="toc-text">requestAnimationFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82xhr%E3%80%81ajax%E3%80%81fetch%E4%B8%8Eaxios"><span class="toc-number">11.</span> <span class="toc-text">异步网络请求xhr、ajax、fetch与axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript"><span class="toc-number">12.</span> <span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%9A%84arugments"><span class="toc-number">13.</span> <span class="toc-text">JS的arugments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">14.</span> <span class="toc-text">JS的原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-set%E3%80%81map%E3%80%81weakset%E3%80%81weakmap%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">JS set、map、weakset、weakmap区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">js 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie%E3%80%81LocalStorage%E3%80%81SessionStorage"><span class="toc-number">17.</span> <span class="toc-text">Cookie、LocalStorage、SessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookies%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">17.1.</span> <span class="toc-text">cookies属性有哪些</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E9%97%AD%E5%8C%85"><span class="toc-number">18.</span> <span class="toc-text">js闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">js内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">19.1.</span> <span class="toc-text">什么是内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#performance%E5%B7%A5%E5%85%B7"><span class="toc-number">19.2.</span> <span class="toc-text">performance工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E8%AF%A5%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%A3%E7%A0%81%E6%AD%A3%E5%9C%A8%E6%B3%84%E6%BC%8F%E5%86%85%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-number">19.3.</span> <span class="toc-text">那该如何判断代码正在泄漏内存呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%91%A2"><span class="toc-number">19.4.</span> <span class="toc-text">什么会导致内存泄漏呢</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E4%B8%8EJavaScript%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">TypeScript与JavaScript区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">21.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">21.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">21.2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-stringify%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">JSON.stringify有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">23.</span> <span class="toc-text">函数执行作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E9%98%B4%E9%97%B4%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">24.</span> <span class="toc-text">js阴间面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-0-2-0-3"><span class="toc-number">24.1.</span> <span class="toc-text">0.1+0.2!&#x3D;&#x3D;0.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">24.2.</span> <span class="toc-text">后端返回一万条数据</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By happy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>