<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机网络 | 豆豆想吃骨头</title><meta name="author" content="happy"><meta name="copyright" content="happy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP基本概念HTTP是什么超文本传输协议：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 HTTP常见状态码  HTTP常见状态码  1xx 提示信息，表示目前是协议处理的中间状态 2xx 成功，报文已经被收到并且被正确处理 200 表示一切正常 204 功能与200基本相同，但是本身响应头没有数据 206 表示响应的资源是其中">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="豆豆想吃骨头">
<meta property="og:description" content="HTTP基本概念HTTP是什么超文本传输协议：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 HTTP常见状态码  HTTP常见状态码  1xx 提示信息，表示目前是协议处理的中间状态 2xx 成功，报文已经被收到并且被正确处理 200 表示一切正常 204 功能与200基本相同，但是本身响应头没有数据 206 表示响应的资源是其中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/dm1.webp">
<meta property="article:published_time" content="2023-03-31T06:42:22.000Z">
<meta property="article:modified_time" content="2023-05-05T04:18:05.599Z">
<meta property="article:author" content="happy">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/dm1.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-05 12:18:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/dm1.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="豆豆想吃骨头"><span class="site-name">豆豆想吃骨头</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-31T06:42:22.000Z" title="发表于 2023-03-31 14:42:22">2023-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-05T04:18:05.599Z" title="更新于 2023-05-05 12:18:05">2023-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><h3 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h3><p>超文本传输协议：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p>
<h3 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h3><img src="https://zyhxwing.gitee.io/images/http/1347_1.png" alt="HTTP常见状态码" style="zoom:50%;">

<p><strong>HTTP常见状态码</strong></p>
<ul>
<li>1xx 提示信息，表示目前是协议处理的中间状态</li>
<li>2xx 成功，报文已经被收到并且被正确处理<ul>
<li>200 表示一切正常</li>
<li>204 功能与200基本相同，但是本身响应头没有数据</li>
<li>206 表示响应的资源是其中的一部分，一般应用于HTTP分块下载</li>
</ul>
</li>
<li>3xx表示客户端请求的资源发生了变动<ul>
<li>301 表示永久重定向，说明请求的资源已经不存在，需要改用新的url来访问</li>
<li>302 表示临时重定向，说明请求的资源还在，但是需要用另一个url来访问<br>301、302会在响应头用location，指明后续要跳转的url</li>
<li>304 协商缓存</li>
</ul>
</li>
<li>4xx表示客户端发送的报文有误，服务器无法处理，表示错误<ul>
<li>400 表示出现错误</li>
<li>403 服务器禁止访问</li>
<li>404 客户端请求的资源服务器没有找到</li>
</ul>
</li>
<li>5xx表示客户端请求报文正确，但服务器处理错误<ul>
<li>500 表示出现错误</li>
<li>501 服务器不支持该功能</li>
<li>502 服务器网关错误</li>
<li>503 服务器繁忙，暂无法响应</li>
</ul>
</li>
</ul>
<h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><p><strong>http 请求报文格式</strong>                      </p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331180243751.png" alt="image-20230331180243751"></p>
<p><strong>http 响应报文格式</strong></p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331180300079.png" alt="image-20230331180300079"></p>
<ul>
<li>host：表示服务器请求的域名</li>
<li>content-length: 表示服务器在返回数据的时候，本次返回的数据长度</li>
<li>connection：keep-alive 表示客户端要求服务器使用tcp持久连接</li>
<li>content-type：服务器回应时告诉客户端本次数据是什么格式 一般取值为utf-8</li>
<li>content-encoding：表示返回的数据用了哪种压缩方法</li>
</ul>
<h3 id="get与post请求区别"><a href="#get与post请求区别" class="headerlink" title="get与post请求区别"></a>get与post请求区别</h3><ul>
<li><p>get请求一般用来请求获取数据</p>
<p>post请求一般作为发送数据到后台，传递数据，创建数据</p>
</li>
<li><p>get请求也可以传参到后台，但是传递的参数则显示在地址栏，安全性低，且参数的长度也有限制（2048字符）</p>
<p>post请求则是将传递的参数放在request body中，不会在地址栏显示，安全性比get请求高，参数没有长度限制</p>
</li>
<li><p>get请求刷新浏览器或者回退没有影响</p>
<p>post请求则会重新请求一遍</p>
</li>
<li><p>get请求可以被缓存，也会保留在浏览器的历史记录中</p>
<p>post请求不会被缓存，也不好保留在浏览器的历史记录中</p>
</li>
<li><p>get请求通常是通过url地址请求</p>
<p>post常见的则是form表单请求</p>
</li>
</ul>
<h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。</p>
<ul>
<li>GET : 请求指定的页面信息，并返回实体主体。</li>
<li>POST : 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>HEAD : 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
</ul>
<p>HTTP 1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<ul>
<li>OPTIONS : 允许客户端查看服务器的性能。</li>
<li>PUT : 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>PATCH : 是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li>
<li>DELETE : 请求服务器删除指定的页面。</li>
<li>TRACE : 回显服务器收到的请求，主要用于测试或诊断。</li>
<li>CONNECT : HTTP 1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li>
</ul>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>200（from disk cache）<br>强缓存根据下面两个http响应头部来实现，表示资源在客户端缓存的有效期</p>
<ul>
<li>cache-control 相对时间，优先级更高</li>
<li>expires 绝对时间</li>
</ul>
<p>实现步骤：<br>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>304<br>协商缓存可以通过两种方式来实现</p>
<p>请求头部 if-modified-since，响应头部 last-modified</p>
<ul>
<li>响应头部 last-modified 该响应资源的最后修改时间</li>
<li>请求头部 if-modified-since 当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>请求头部 if-none-match，响应头部 etag</p>
<ul>
<li>响应头部 etag 唯一标识响应资源</li>
<li>请求头部 if-none-match 当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。</p>
<p>注意，协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<h4 id="三种刷新操作对-http-缓存的影响"><a href="#三种刷新操作对-http-缓存的影响" class="headerlink" title="三种刷新操作对 http 缓存的影响"></a>三种刷新操作对 http 缓存的影响</h4><p>正常操作：地址栏输入 url，跳转链接，前进后退等。强制缓存有效，协商缓存有效<br>手动刷新：f5，点击刷新按钮，右键菜单刷新。强制缓存失效，协商缓存有效<br>强制刷新：ctrl + f5，shift+command+r。强制缓存失效，协商缓存失效。</p>
<h3 id="HTTP特性与演变"><a href="#HTTP特性与演变" class="headerlink" title="HTTP特性与演变"></a>HTTP特性与演变</h3><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p><strong>优点</strong></p>
<ul>
<li>简单，header+body，头部内容为key-value</li>
<li>灵活、易于拓展</li>
<li>应用广泛</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>无状态，减少服务器负担的同时也需要进行额外的身份认证（cookie）</li>
<li>明文传输，不安全</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>长连接，服务器和客户端可以长时间保持连接</li>
<li>管道网络传输，发送请求不用等响应就可以发送接下来的请求</li>
<li>队头堵塞，响应请求需要一步一步响应，如果队伍头部的响应很慢，接下来的响应就会堵塞</li>
</ul>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p><strong>特性</strong></p>
<ul>
<li><strong>头部压缩</strong>，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li>
<li><strong>二进制格式</strong>，增加了信息传输的效率</li>
<li><strong>数据流</strong>，对数据包做标记，指出它属于哪个回应。在 HTTP/2 中每个请求或响应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID），不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</li>
<li><strong>多路复用</strong>，在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li>
<li><strong>服务器推送</strong>，服务端不再是被动地响应，可以主动向客户端发送消息。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>TCP队头堵塞问题。HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</li>
</ul>
<p><strong>简而言之就是某个TCP的packet也就是序列号丢失了，那么之后所有的TCP都需要等待重传机制返回丢失的包，才能继续运行，否则数据不连续是无法被读取到的</strong></p>
<h4 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h4><p><strong>优点</strong></p>
<ul>
<li><strong>无队头堵塞，基于UDP实现HTTP链接</strong>，通过QUIC协议实现可靠传输。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。</li>
<li><strong>更快的连接速度</strong>，QUIC内部包含了TLS可以同时完成建立连接与密钥协商</li>
<li><strong>连接迁移</strong>。基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。<strong>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</strong>，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</li>
</ul>
<p><strong>缺点</strong></p>
<p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTP与HTTPS区别"><a href="#HTTP与HTTPS区别" class="headerlink" title="HTTP与HTTPS区别"></a>HTTP与HTTPS区别</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h3 id="HTTPS改进内容之TLS协议"><a href="#HTTPS改进内容之TLS协议" class="headerlink" title="HTTPS改进内容之TLS协议"></a>HTTPS改进内容之TLS协议</h3><ul>
<li>信息加密： HTTP 交互信息是被加密的，第三方就无法被窃取；</li>
<li>校验机制：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li>
<li>身份证书：证明淘宝是真的淘宝网；</li>
</ul>
<h3 id="SSL-TLS握手详解"><a href="#SSL-TLS握手详解" class="headerlink" title="SSL/TLS握手详解"></a>SSL/TLS握手详解</h3><ul>
<li>TLS第一次握手<ul>
<li>客户端发送Client Hello消息，包含了版本号、支持的密码套件列表、随机数Client Random</li>
</ul>
</li>
<li>TLS第二次握手<ul>
<li>服务端收到Client Hello消息之后，首先会确认版本号是否支持，然后从密码套件列表中选择一个密码套件RSA，然后生成出一个随机数Server Random，最后返回Server Hello消息，包含了以上内容</li>
<li>服务端发送Server Certificate给客户端，这个消息里含有数字证书</li>
<li>服务端发送Server Hello Done给客户端，代表本次握手结束，已经把东西给了客户端</li>
</ul>
</li>
<li>TLS第三次握手<ul>
<li>证书认证机构CA签发证书流程<ul>
<li>CA把持有者的信息打包，进行hash计算，得到一个hash值、</li>
<li>CA会使用自己的私钥对hash值加密，生成签名 Certificate Signature</li>
<li>将签名添加到文件证书上，形成数字证书</li>
</ul>
</li>
<li>客户端验证数字证书流程<ul>
<li>客户端会使用相同的算法也生成一个hash值</li>
<li>客户端再收到数字证书后，根据操作系统提供的CA的公钥对证书解密，获得了CA传递的hash值</li>
<li>两个hash值对比，相同则为可以信赖的证书</li>
</ul>
</li>
<li>客户端验证证书完毕之后，会生成一个新的随机数pre-master，用服务器RSA公钥加密该随机数，通过Client Key Exchange消息传递给服务端</li>
<li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)</li>
<li>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</li>
<li>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是 <strong>对称密钥</strong>，用于对后续的 HTTP 请求/响应的数据加解密。</li>
<li>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。</li>
<li>然后，客户端再发一个「Encrypted Handshake Message（Finishd） 」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</li>
</ul>
</li>
<li>TLS第四次握手<ul>
<li>服务器发送Change Cipher Spec、Encrypted Handshake Message（Finishd） 消息，此时双方都验证加密和解密没问题，则握手完毕</li>
</ul>
</li>
</ul>
<p><strong>密钥交换算法：因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</strong></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：源地址、源端口、目的地址、目的端口</p>
<h3 id="为何TCP可靠UDP不可靠"><a href="#为何TCP可靠UDP不可靠" class="headerlink" title="为何TCP可靠UDP不可靠"></a>为何TCP可靠UDP不可靠</h3><ul>
<li>TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。对于每份报文也存在校验，保证每份报文可靠性。</li>
<li>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。仅仅在IP数据报头部加入校验和复用。UDP没有服务器和客户端的概念。UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</li>
</ul>
<h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ol>
<li><strong>连接</strong> : 连接TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。</li>
<li><strong>服务对象、连接数</strong> : 服务对象TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</li>
<li><strong>可靠性</strong> : 可靠性TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。</li>
<li><strong>流量控制</strong> : 拥塞控制、流量控制TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
<li><strong>首部开销</strong> : 首部开销TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
<li><strong>传输方式</strong> : 传输方式TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
<li><strong>分片传播</strong> : 分片不同TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
<li><strong>应用</strong> : 由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：FTP 文件传输；HTTP / HTTPS；由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS 、SNMP 等；视频、音频等多媒体通信；广播通信。</li>
</ol>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331162250850.png" alt="image-20230331162250850"></p>
<ul>
<li>一开始，客户端和服务端都处于<strong>close</strong> 状态。先是服务端主动监听某个端口，处于 <strong>listen</strong> 状态</li>
<li>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把<strong>SYN 标志位置为 1</strong> ，表示 SYN 报文。接着<strong>把第一个 SYN 报文发送给服务端</strong>，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <strong>SYN-SENT</strong> 状态。</li>
<li>服务端在收到客户端的SYN请求之后，会初始化自己的序号，将此序号填入TCP首部的序号字段中，其次把TCP首部的确认应答号字段填入client_isn + 1，接着把 <strong>SYN 和 ACK 标志位置为1</strong> 。把该报文发给客户端，该报文也不包含应用层数据，之后服务器处于 <strong>SYN-RCVD</strong> 状态。</li>
<li>客户端在收到服务端报文后，还要再向服务端回应最后一个应答报文，首先将该报文的<strong>ACK置为1</strong>，其次确认应答号填入server_isn+1，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，指挥客户端处于<strong>established</strong>状态。</li>
<li>服务端在收到客户端的应答报文之后，也进入<strong>established</strong>状态。</li>
</ul>
<h4 id="为什么不是四次握手、两次握手"><a href="#为什么不是四次握手、两次握手" class="headerlink" title="为什么不是四次握手、两次握手"></a>为什么不是四次握手、两次握手</h4><p>1.<strong>三次握手才可以阻止重复历史连接的初始化（主要原因</strong>）</p>
<p><strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。</strong></p>
<p>因此，要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p>
<p>2.<strong>三次握手才可以同步双方的初始序列号</strong></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：接收方可以去除重复的数据；接收方可以根据数据包的序列号按序接收；可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>
<p><strong>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</strong></p>
<p>3.<strong>三次握手才可以避免资源浪费</strong></p>
<p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p><strong>不使用「两次握手」和「四次握手」的原因：<br>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</strong></p>
<h4 id="三次握手每次报文丢失后果"><a href="#三次握手每次报文丢失后果" class="headerlink" title="三次握手每次报文丢失后果"></a>三次握手每次报文丢失后果</h4><p><strong>第一次握手丢失</strong></p>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。<strong>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。如果在重传次数超过最大重传次数之后，服务端依旧没响应ACK，则会断开TCP连接</strong></p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331165823382.png" alt="image-20230331165823382"></p>
<p><strong>第二次握手丢失</strong></p>
<p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。</p>
<p>第二次握手的 SYN-ACK 报文其实有两个目的 ：第二次握手里的 ACK， 是对第一次握手的确认报文；第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</p>
<p><strong>因此，当第二次握手丢失了，客户端和服务端都会重传：<br>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。</strong></p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170108102.png" alt="image-20230331170108102"></p>
<p><strong>第三次握手丢失</strong></p>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p>
<p><strong>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</strong></p>
<p>注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170209247.png" alt="image-20230331170209247"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="https://zyhxwing.gitee.io/images/http/1351_1.png" alt="四次挥手" style="zoom:50%;">

<p><strong>四次挥手</strong></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 <strong>FIN 报文</strong>，之后客户端进入 <strong>FIN_WAIT_1</strong>状态。</li>
<li>服务端收到该报文后，就向客户端发送 <strong>ACK</strong> 应答报文，接着服务端进入 <strong>CLOSED_WAIT</strong> 状态。</li>
<li>客户端收到服务端的 ACK 应答报文后，之后进入 <strong>FIN_WAIT_2</strong>状态。</li>
<li>等待服务端处理完数据后，也向客户端发送<strong>FIN 报文</strong>，之后服务端进入 <strong>LAST_ACK</strong> 状态。</li>
<li>客户端收到服务端的 FIN 报文后，<strong>回一个 ACK应答报文</strong>，之后进入 <strong>TIME_WAIT</strong> 状态</li>
<li>服务器收到了 ACK 应答报文后，就进入了 <strong>CLOSED</strong> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 2MSL 一段时间后，自动进入 <strong>CLOSED</strong> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p>
<h4 id="为什么需要挥手四次"><a href="#为什么需要挥手四次" class="headerlink" title="为什么需要挥手四次"></a>为什么需要挥手四次</h4><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p>
<p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p>
<h4 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h4><p>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</p>
<h4 id="四次挥手丢失了会发生什么"><a href="#四次挥手丢失了会发生什么" class="headerlink" title="四次挥手丢失了会发生什么"></a>四次挥手丢失了会发生什么</h4><p><strong>第一次挥手丢失</strong></p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，<strong>重传 FIN 报文</strong>，重发次数由 tcp_orphan_retries 参数控制。当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，直接进入到 close 状态。</p>
<p><strong>第二次挥手丢失</strong></p>
<p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 CLOSE_WAIT 状态。在前面我们也提了，<strong>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手 ，或者达到最大的重传次数。</p>
<p><strong>第三次挥手丢失</strong></p>
<p><strong>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文</strong>，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<p><strong>第四次挥手丢失</strong></p>
<p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。如果第四次挥手的 ACK 报文没有到达服务端，<strong>服务端就会重发 FIN 报文</strong>，重发次数仍然由前面介绍过的</p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170307694.png" alt="image-20230331170307694">          <img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170326836.png" alt="image-20230331170326836"></p>
<p><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170507698.png" alt="image-20230331170507698" style="zoom:80%;"><img src="/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230331170525573.png" alt="image-20230331170525573" style="zoom:80%;"></p>
<h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><ol>
<li><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
</li>
<li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
</li>
<li><p>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
<li><p>TCP 的接收端会丢弃重复的数据。</p>
</li>
<li><p>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
</li>
<li><p>拥塞控制： 当网络拥塞时，减少数据的发送。</p>
</li>
<li><p>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li><p>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
<li></li>
</ol>
<h2 id="OSI七层模型和TCP-IP四层模型"><a href="#OSI七层模型和TCP-IP四层模型" class="headerlink" title="OSI七层模型和TCP/IP四层模型"></a>OSI七层模型和TCP/IP四层模型</h2><p><img src="https://zyhxwing.gitee.io/images/http/1355_1.png" alt="OSI七层模型和TCP/IP四层模型"></p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul>
<li>应用层<br>网络服务与最终用户的一个接口。<br>协议有： HTTP（超文本传输协议） FTP（文本传输协议） TFTP（简单文本传输协议） SMTP（简单邮件传输协议） SNMP（简单网络管理协议） DNS（域名系统） TELNET（远程终端协议） HTTPS（超文本传输安全协议） POP3（邮件协议版本3） DHCP（动态主机配置协议）</li>
<li>表示层<br>数据的表示、安全、压缩。<br>格式有：JPEG、ASCll、EBCDIC、加密格式等</li>
<li>会话层<br>建立、管理、终止会话。<br>对应主机进程，指本地与远程主机正在进行的会话</li>
<li>传输层<br>定义传输数据的协议端口号，以及流控和差错校验<br>协议有：TCP、UD，数据包一旦离开网卡即进入网络传输层</li>
<li>网络层<br>进行逻辑地址寻址，实现不通网络之间的路径选择（路由选路）<br>协议有：ICMP、IGMP、IP（IPV4 IPV6）</li>
<li>数据链路层<br>建立逻辑连接、进行硬件寻址，差错校验等功能（有底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不纠正</li>
<li>物理层<br>建立、维护、断开物理连接（由底层网络定义协议）</li>
</ul>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><ul>
<li><p>应用层<br>应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.</p>
</li>
<li><p>传输层<br>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP).TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.</p>
</li>
<li><p>网络层<br>主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务</p>
</li>
<li><p>网络接口层<br>网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">happy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://example.com/2023/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">豆豆想吃骨头</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" title="浏览器"><img class="cover" src="/img/dm1.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浏览器</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/31/css/" title="css"><img class="cover" src="/img/%E7%89%8C%E7%89%8Ccss.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">css</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">HTTP基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">HTTP是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">HTTP常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">HTTP常见字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">get与post请求区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">http请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.2.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%B7%E6%96%B0%E6%93%8D%E4%BD%9C%E5%AF%B9-http-%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.6.3.</span> <span class="toc-text">三种刷新操作对 http 缓存的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7%E4%B8%8E%E6%BC%94%E5%8F%98"><span class="toc-number">1.7.</span> <span class="toc-text">HTTP特性与演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">HTTP 1.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP2"><span class="toc-number">1.7.2.</span> <span class="toc-text">HTTP2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP3"><span class="toc-number">1.7.3.</span> <span class="toc-text">HTTP3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">2.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP与HTTPS区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%94%B9%E8%BF%9B%E5%86%85%E5%AE%B9%E4%B9%8BTLS%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.</span> <span class="toc-text">HTTPS改进内容之TLS协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.3.</span> <span class="toc-text">SSL&#x2F;TLS握手详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95TCP%E5%8F%AF%E9%9D%A0UDP%E4%B8%8D%E5%8F%AF%E9%9D%A0"><span class="toc-number">3.1.</span> <span class="toc-text">为何TCP可靠UDP不可靠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">TCP与UDP区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.3.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">为什么不是四次握手、两次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%AF%8F%E6%AC%A1%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E5%90%8E%E6%9E%9C"><span class="toc-number">3.3.2.</span> <span class="toc-text">三次握手每次报文丢失后果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.4.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8C%A5%E6%89%8B%E5%9B%9B%E6%AC%A1"><span class="toc-number">3.4.1.</span> <span class="toc-text">为什么需要挥手四次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL"><span class="toc-number">3.4.2.</span> <span class="toc-text">为什么四次挥手释放连接时需要等待2MSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.3.</span> <span class="toc-text">四次挥手丢失了会发生什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">3.5.</span> <span class="toc-text">TCP如何实现可靠传输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">OSI七层模型和TCP&#x2F;IP四层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">OSI七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">TCP&#x2F;IP四层模型</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By happy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>